{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Andar Package","text":"<p>Andar is a Python library that provides an abstraction layer for managing path structures, helping to create and parse paths programmatically via templated file paths.</p>"},{"location":"#install-package","title":"Install Package","text":"<p>With pip: <pre><code>pip install andar\n</code></pre></p>"},{"location":"#key-features","title":"Key features","text":""},{"location":"#clean-code","title":"Clean code","text":"<p>Andar promotes clean code by using a composition approach to avoid inheritance hell. Furthermore, it allows to define a path conventions in a single place using a clear and intuitive syntax. The use of templated path strings with field definitions helps to avoid the error-prone split/index syntax</p>"},{"location":"#reusability","title":"Reusability","text":"<p>Andar allows using a single path convention via a PathModel for both generating and parsing paths. PathModels can be reused to create new path conventions with minimal effort without modifying the parent PathModel.</p>"},{"location":"#separation-of-concerns","title":"Separation of Concerns","text":"<p>Andar helps to separate I/O layer from path generation layer resulting in a code easier to maintain.</p>"},{"location":"#predictability","title":"Predictability","text":"<p>Andar provides field name checking via regular expressions and functions to assert bijection between path generation and path parsing.</p>"},{"location":"#flexibility","title":"Flexibility","text":"<p>Andar allows for a quick start just by defining a path template thanks to its predefined fields and patterns. It also  include more advance capabilities for customizing field parsing and generation via regular expression and string converters while  maintaining a simple syntax.</p>"},{"location":"#lightweight","title":"Lightweight","text":"<p>Andar is written using standard Python library, so it is very lightweight without any external dependencies.</p>"},{"location":"#concepts","title":"Concepts","text":""},{"location":"#pathmodel","title":"PathModel","text":"<p>PathModel is the main class that allows to easy define path conventions and manage path structures. It is based on two main components: templates and fields. Templates are strings that define the names of the fields in the path structure using a simple syntax  (inspired by f-string) , for example: <code>\"/{folder}/{prefix}_{name}_{suffix}.{ext}\"</code> Fields are the basic components that allow to map an object to a string in order to build or parse a path. Fields  are defined via a class named FieldConf (see next section).</p> <p>A PathModel can be defined only with the template string because there is already a default value for fields. Once a PathModel is defined it can be used to generate a new path or to parse an existing path in order to get  its fields. See Quick Start for a simple example. For more details check the Docs.</p>"},{"location":"#fieldconf","title":"FieldConf","text":"<p>FieldConf is the class that defines how to parse and build a given field. It can be customized by specifying its regex pattern and how to convert the input object to a string and vice versa. It comes with a handy way for automatically manage dates and datetimes. See Examples section for some applied use cases. For more details check the Docs.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Simple PathModel definition using default field configurations:</p> <pre><code>from andar import PathModel\n\nsimple_path_model = PathModel(\n    template=\"/{base_folder}/{subfolder}/{base_name}__{suffix}.{extension}\"\n)\n</code></pre> <p>Generate a path:</p> <pre><code>result_path = simple_path_model.get_path(\n    base_folder=\"parent_folder\",\n    subfolder=\"other_folder\",\n    base_name=\"mydata\",\n    suffix=\"2000-01-01\",\n    extension=\"csv\",\n)\nprint(result_path)\n</code></pre> <pre><code>\"/parent_folder/other_folder/mydata__2000-01-01.csv\"\n</code></pre> <p>Parse a path:</p> <pre><code>file_path = \"/data/reports/summary__2025-12-31.csv\"\nparsed_fields = simple_path_model.parse_path(file_path)\nprint(parsed_fields)\n</code></pre> <pre><code>{\n    'base_folder': 'data', \n    'subfolder': 'reports', \n    'base_name': 'summary', \n    'suffix': '2025-12-31', \n    'extension': 'csv',\n}\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#how-to-create-a-path-generator-parser-for-a-date-tree-structure","title":"How to create a path generator / parser for a date tree structure","text":"<p>Define a PathModel following a date tree folder structure with datetime a suffix using the next template and fields:</p> <pre><code>from andar import FieldConf, PathModel, SafePatterns\n\ndate_archived_pm = PathModel(\n    template=\"{base_path}/{subfolder}/{date_path}/{date_prefix}_{name}_{datetime_suffix}.{ext}\",\n    fields={\n        \"base_path\": FieldConf(pattern=SafePatterns.DIRPATH),\n        \"subfolder\": FieldConf(pattern=SafePatterns.NAME),\n        \"date_path\": FieldConf(pattern=r\"\\d{4}/\\d{2}/\\d{2}\", date_format=\"%Y/%m/%d\"),\n        \"date_prefix\": FieldConf(pattern=r\"\\d{4}-\\d{2}-\\d{2}\", date_format=\"%Y-%m-%d\"),\n        \"name\": FieldConf(pattern=SafePatterns.FIELD),\n        \"datetime_suffix\": FieldConf(pattern=r\"\\d{8}_\\d{6}\", datetime_format=\"%Y%m%d_%H%M%S\"),\n        \"ext\": FieldConf(pattern=SafePatterns.EXTENSION),\n    },\n)\n</code></pre> <p>Then, for generating the paths just iterate over dates:</p> <pre><code>import datetime as dt\n\nbase_path = \"/company/reports\"\nsubfolder = \"finance\"\nreport_name = \"revenue\"\nextension = \"xls\"\nstart_date = dt.date(2025, 12, 1)\nreport_date_list = [start_date + dt.timedelta(days=d) for d in range(10)]\n\nfor report_date in report_date_list:\n    creation_datetime = dt.datetime.now()\n    report_path = date_archived_pm.get_path(\n        base_path=base_path,\n        subfolder=subfolder,\n        date_path=report_date,\n        date_prefix=report_date,\n        name=report_name,\n        datetime_suffix=creation_datetime,\n        ext=extension,\n    )\n    print(report_path)\n</code></pre> <p>For parsing already existing paths use a library that allows to recursive search (e.g. pathlib, glob, os, etc)  and output a fullpath for each file:</p> <pre><code>import pathlib\nbase_path = \"/company/reports\"\nsearch_folder = pathlib.Path(base_path)\npath_list = [str(i) for i in search_folder.rglob(\"*\") if i.is_file()]\n\nfor file_path in path_list:\n    parsed_fields = date_archived_pm.parse_path(file_path)\n    print(parsed_fields)\n</code></pre>"},{"location":"#how-to-define-path-conventions-for-a-datalake","title":"How to define path conventions for a datalake","text":"<p>For example Data Mesh propose conventions for separating data into domains, layers and products.  This could be implemented with the following PathModel template and fields:</p> <pre><code>from andar import FieldConf, PathModel, SafePatterns\n\ndata_mesh_pm = PathModel(\n    template=\"/{domain}/{layer}/{product}/{aggregation}/{date}_{product}.{ext}\",\n    fields={\n        \"domain\": FieldConf(pattern=SafePatterns.NAME),  # sales, marketing, HR, finance, etc\n        \"layer\": FieldConf(pattern=SafePatterns.NAME),  # raw, intermediate, mart, etc\n        \"product\": FieldConf(pattern=SafePatterns.NAME),  # orders, revenues, taxes, campaigns, etc\n        \"aggregation\": FieldConf(pattern=SafePatterns.NAME),  # daily, weekly, monthly, etc\n        \"date\": FieldConf(pattern=r\"\\d{8}\", datetime_format=\"%Y%m%d\"),  # product date\n        \"ext\": FieldConf(pattern=SafePatterns.EXTENSION),  # csv, xls, parquet, etc\n    },\n)\n</code></pre> <p>For improving traceability, it's a good practice to also include run datetime (i.e. generation date)  as a simple version system: <pre><code>from andar import FieldConf, PathModel, SafePatterns\n\ndata_mesh_pm = PathModel(\n    template=\"/{domain}/{layer}/{product}/{aggregation}/{product_date}_{product}_{run_datetime}.{ext}\",\n    fields={\n        \"domain\": FieldConf(pattern=SafePatterns.NAME),  # sales, marketing, HR, finance, etc\n        \"layer\": FieldConf(pattern=SafePatterns.NAME),  # raw, intermediate, mart, etc\n        \"product\": FieldConf(pattern=SafePatterns.NAME),  # orders, revenues, taxes, campaigns, etc\n        \"aggregation\": FieldConf(pattern=SafePatterns.NAME),  # daily, weekly, monthly, etc\n        \"product_date\": FieldConf(pattern=r\"\\d{8}\", datetime_format=\"%Y%m%d\"),  # product target date\n        \"run_datetime\": FieldConf(pattern=r\"\\d{8}_\\d{6}\", datetime_format=\"%Y%m%d_%H%M%S\"),  # generation datetime\n        \"ext\": FieldConf(pattern=SafePatterns.EXTENSION),  # csv, xls, parquet, etc\n    },\n)\n</code></pre></p>"},{"location":"#how-to-reorganize-files-and-folders-in-a-datalake","title":"How to reorganize files and folders in a datalake","text":"<p>In this example we will reorganize a flatten file structure into a nested one. First define the two PathModels, the old one and the new one:</p> <pre><code>from andar import FieldConf, PathModel, SafePatterns\n\nold_flat_pm = PathModel(\n    template=\"{base_path}/{category}_{name}_{date}.{ext}\",\n    fields={\n        \"base_path\": FieldConf(pattern=SafePatterns.DIRPATH),\n        \"category\": FieldConf(pattern=SafePatterns.NAME),\n        \"name\": FieldConf(pattern=SafePatterns.FIELD),\n        \"date\": FieldConf(pattern=r\"\\d{8}\", datetime_format=\"%Y%m%d\"),\n        \"ext\": FieldConf(pattern=SafePatterns.EXTENSION),\n    },\n)\n\n# we can just update the template if the fields are de same\nnew_nested_pm = old_flat_pm.update(\n    template=\"{base_path}/{category}/{date}/{name}.{ext}\"\n)\n</code></pre> <p>Example of file creating in a temporary directory using a flatten structure with the old PathModel:</p> <pre><code>import pathlib\nimport tempfile\nimport datetime as dt\n\nbase_path = tempfile.mkdtemp()\nstart_date = dt.datetime(2025, 12, 1)\ndate_list = [start_date + dt.timedelta(days=d) for d in range(10)]\n\nfor date in date_list:\n    creation_datetime = dt.datetime.now()\n    file_path = old_flat_pm.get_path(\n        base_path=base_path,\n        category=\"sales\",\n        name=\"orders\",\n        date=date,\n        ext=\"csv\",\n    )\n    print(file_path)\n    pathlib.Path(file_path).touch()  # create an empty file\n</code></pre> <p>Example of nesting file paths using the parser of the old PathModel and the get_path of the new PathModel:</p> <pre><code># First list existing files in target base path\nsearch_folder = pathlib.Path(base_path)\npath_list = [str(i) for i in search_folder.rglob(\"*\") if i.is_file()]\n\nfor file_path in path_list:\n    parsed_fields = old_flat_pm.parse_path(file_path)\n    # As the fields are the same we can reuse them directly\n    new_file_path = new_nested_pm.get_path(**parsed_fields)\n    # create new parent directories\n    pathlib.Path(new_file_path).parent.mkdir(parents=True, exist_ok=True)\n    # move old file to new location using the new name\n    pathlib.Path(file_path).replace(new_file_path)\n</code></pre> <p>The same strategy could be adapted to flatten a nested path structure using PathModels.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>See the official documentation to learn more.</p>"},{"location":"#package-name-origin","title":"Package name origin","text":"<p>The package name originates from a verse by the Spanish poet Antonio Machado:</p> <p>\"Caminante, no hay camino, se hace camino al andar.\"</p> <p>Antonio Machado</p>"},{"location":"reference/andar/","title":"andar","text":""},{"location":"reference/andar/#andar","title":"<code>andar</code>","text":""},{"location":"reference/andar/#andar.FieldConf","title":"<code>FieldConf</code>  <code>dataclass</code>","text":"<p>FieldConf allows to configure how a path field is validated, parsed and processed</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regex pattern used to validate the input of get_path and get_parent_path, and also to get fields      using PathModel.parse_path(). By default, it used SafePatterns.NAME.</p> <code>NAME</code> <code>description</code> <code>str | None</code> <p>String used as documentation for the FieldConf.</p> <code>None</code> <code>date_format</code> <code>str | None</code> <p>date_format and datetime_format are used in get_path and get_parent_path for accepting either a             string or a datetime object that can be formated to an input string for a the given template.             They are also used for validating the parsed field when using parse_path and for defining how             to cast the string (to date or to datetime, depending on the argument that was used).</p> <code>None</code> <code>datetime_format</code> <code>str | None</code> <p>See description of date_format parameter.</p> <code>None</code> <code>is_optional</code> <code>bool | None</code> <p>allows to omit a field during the path generation (get_path and get_parent_path)             or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must             be constrained, otherwise the PathModel class may have an unexpected behaviour.             For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.</p> <code>None</code> Source code in <code>andar/field_conf.py</code> <pre><code>@dataclass\nclass FieldConf:\n    \"\"\"\n    FieldConf allows to configure how a path field is validated, parsed and processed\n\n    Params:\n        pattern: Regex pattern used to validate the input of get_path and get_parent_path, and also to get fields\n                 using PathModel.parse_path(). By default, it used SafePatterns.NAME.\n        description: String used as documentation for the FieldConf.\n        date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a\n                        string or a datetime object that can be formated to an input string for a the given template.\n                        They are also used for validating the parsed field when using parse_path and for defining how\n                        to cast the string (to date or to datetime, depending on the argument that was used).\n        datetime_format: See description of date_format parameter.\n        is_optional: allows to omit a field during the path generation (get_path and get_parent_path)\n                        or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must\n                        be constrained, otherwise the PathModel class may have an unexpected behaviour.\n                        For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.\n    \"\"\"\n\n    pattern: str = SafePatterns.NAME\n    description: str | None = None\n    date_format: str | None = None\n    datetime_format: str | None = None\n    is_optional: bool | None = None\n    str_to_var: Callable | None = None\n    var_to_str: Callable | None = None\n\n    def __post_init__(self):\n        has_date_converter = self.date_format is not None\n        has_datetime_converter = self.datetime_format is not None\n        has_custom_converter = self.var_to_str is not None or self.str_to_var is not None\n        active_converters_num = sum([has_date_converter, has_datetime_converter, has_custom_converter])\n        if active_converters_num &gt; 1:\n            raise ValueError(f\"Maximum one field converter is allowed, but {active_converters_num} were found\")\n\n    def __repr__(self):\n        formatted_fields = []\n        for k, v in vars(self).items():\n            if v is None:\n                continue\n            v_str = f\"'{v}'\" if isinstance(v, str) else v.__qualname__\n            field_str = f\"{k}={v_str}\"\n            formatted_fields.append(field_str)\n        formatted_fields_str = \", \".join(formatted_fields)\n        repr = f\"FieldConf({formatted_fields_str})\"\n        return repr\n\n    def replace(self, **kwargs: Any) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        Params:\n            **kwargs: Attributes (parameters) to be replaced\n\n        Returns:\n            A copy of the object with the attributes replaced\n        \"\"\"\n        field_conf = replace(self, **kwargs)\n        return field_conf\n</code></pre>"},{"location":"reference/andar/#andar.FieldConf.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Attributes (parameters) to be replaced</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the object with the attributes replaced</p> Source code in <code>andar/field_conf.py</code> <pre><code>def replace(self, **kwargs: Any) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    Params:\n        **kwargs: Attributes (parameters) to be replaced\n\n    Returns:\n        A copy of the object with the attributes replaced\n    \"\"\"\n    field_conf = replace(self, **kwargs)\n    return field_conf\n</code></pre>"},{"location":"reference/andar/#andar.PathModel","title":"<code>PathModel</code>","text":"<p>PathModel allows to define, build and parse templated file paths</p> <p>It defines a path via a template and its fields. Once instantiated, it allows to build new paths and to parse path strings to recover individual fields.</p> <p>Attributes:</p> Name Type Description <code>template</code> <code>str</code> <p>A template string</p> <code>fields</code> <code>dict[str, FieldConf]</code> <p>A dictionary of FieldConfs</p> Source code in <code>andar/path_model.py</code> <pre><code>class PathModel:\n    \"\"\"\n    PathModel allows to define, build and parse templated file paths\n\n    It defines a path via a template and its fields. Once instantiated, it allows to build new paths\n    and to parse path strings to recover individual fields.\n\n    Attributes:\n        template: A template string\n        fields: A dictionary of FieldConfs\n    \"\"\"\n\n    template: str\n    fields: dict[str, FieldConf]\n    default_field: FieldConf\n    parent_template: str\n    description: str\n    compiled_regex: re.Pattern\n    _dir_sep: str = \"/\"\n\n    def __init__(\n        self,\n        template: str,\n        *,\n        fields: dict[str, FieldConf] | None = None,\n        default_field: FieldConf | None = None,\n        parent_template: str | None = None,\n        description: str | None = None,\n    ):\n        self.template = template\n        self._fields = fields\n        self._parent_template = parent_template\n        self._default_field = default_field\n        self._description = description\n\n        if parent_template is None:\n            parent_template = os.path.dirname(self.template)\n        check_parent_path_template(template, parent_template)\n        self.parent_template = parent_template\n\n        if default_field is None:\n            default_field = FieldConf()\n        self.default_field = default_field\n\n        new_fields = {}\n        template_field_names = get_template_fields_names(template)\n        for field_name in template_field_names:\n            new_fields[field_name] = default_field\n\n        if fields is not None:\n            new_fields.update(fields)\n        self.fields = new_fields\n\n        new_field_names = list(new_fields.keys())\n        check_expected_fields(template_field_names, new_field_names)\n\n        if description is None:\n            description = \"\"\n        self.description = description\n\n        self.compiled_regex = compile_path_regex(\n            template=self.template,\n            fields=self.fields,\n            ds=self._dir_sep,\n        )\n\n    def __repr__(self):\n        ident = \"  \"\n        formatted_fields = \"\\n\".join([f\"{ident * 2}'{k}': {v},\" for k, v in self.fields.items()])\n        formatted_args = [f\"{ident}template='{self.template}',\"]\n        if self._fields is not None:\n            formatted_args.append(f\"{ident}fields={{\\n{formatted_fields}\\n  }},\")\n        if self._default_field is not None:\n            formatted_args.append(f\"{ident}default_field={self.default_field},\")\n        if self._parent_template is not None:\n            formatted_args.append(f\"{ident}parent_template='{self.parent_template}',\")\n        if self._description is not None:\n            formatted_args.append(f\"{ident}description='{self.description}',\")\n        formatted_args_str = \"\\n\".join(formatted_args)\n        repr = f\"PathModel(\\n{formatted_args_str}\\n)\"\n        return repr\n\n    def replace(self, copy_description: bool = False, **kwargs: Any) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        Params:\n            **kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n\n        Returns:\n            A PathModel instance\n        \"\"\"\n        default_parent_template = None  # default value when a new template is given, if not it reuse a previous one\n        if \"template\" not in kwargs:\n            kwargs[\"template\"] = self.template\n            default_parent_template = self._parent_template\n        if \"parent_template\" not in kwargs:\n            kwargs[\"parent_template\"] = default_parent_template  # reset to None when a new template is set\n        if \"fields\" not in kwargs:\n            kwargs[\"fields\"] = self._fields\n        if \"default_field\" not in kwargs:\n            kwargs[\"default_field\"] = self._default_field\n        default_description = None\n        if copy_description:\n            default_description = self._description\n        if \"description\" not in kwargs:\n            kwargs[\"description\"] = default_description\n\n        return self.__class__(**kwargs)\n\n    def update(self, **kwargs: Any) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object updating attributes with the given keyword arguments\n\n        Params:\n            **kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                      Fields set to `None` will be reset to default_field, if no longer present in the template,\n                      they will be removed instead.\n\n        Returns:\n            A PathModel instance\n        \"\"\"\n        fields = self.fields.copy()\n        if \"fields\" in kwargs:\n            fields.update(kwargs[\"fields\"])\n            fields_names = list(fields.keys())\n            [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n            kwargs[\"fields\"] = fields\n        return self.replace(**kwargs)\n\n    def __call__(self, **kwargs) -&gt; Self:\n        if not kwargs:\n            return self\n        return self.replace(**kwargs)\n\n    def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n        \"\"\"\n        Parse a file path\n\n        Params:\n            file_path: String to be parsed.\n            raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n\n        Returns:\n            Dictionary where each key represent a field of the template and each value is the corresponding parsed\n            string (or converted object)\n        \"\"\"\n\n        match = self.compiled_regex.match(file_path)\n        if not match:\n            if raise_error:\n                raise ValueError(f\"Invalid path '{file_path}', expected pattern: '{self.compiled_regex.pattern}'\")\n            return None\n        parsed_fields_dict = match.groupdict()\n        parsed_fields_dict = fusion_deduplicated_fields(parsed_fields_dict)\n\n        processed_fields = process_parsed_fields_values(self.fields, parsed_fields_dict)\n        return processed_fields\n\n    @classmethod\n    def _get_path(\n        cls,\n        template: str,\n        fields_conf: dict[str, FieldConf],\n        fields_values_dict: dict[str, Any],\n    ) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        Params:\n            template: A template that follows string.Formatter() syntax.\n            fields_conf: Dictionary of fields configurations, where keys are field names and values are FieldConf\n                         instances.\n            fields_values_dict: Input parameters dict that maps template fields to values.\n\n        Returns:\n            A path string.\n        \"\"\"\n        fields_values_dict = fields_values_dict.copy()\n        template_field_names = get_template_fields_names(template)\n        missing_field_names = [field for field in template_field_names if field not in fields_values_dict]\n\n        for field_name in missing_field_names:\n            is_optional = fields_conf[field_name].is_optional\n            if is_optional:\n                fields_values_dict[field_name] = None\n\n        given_field_names = list(fields_values_dict.keys())\n        check_expected_fields(template_field_names, given_field_names)\n        fields_values_dict = prepare_fields_values(fields_values_dict, fields_conf)\n        new_path = template.format(**fields_values_dict)\n        new_path = os.path.normpath(new_path)\n        return new_path\n\n    def get_path(self, **kwargs: Any) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        Params:\n            **kwargs: Input parameters that maps template fields to values.\n\n        Returns:\n            A path string.\n        \"\"\"\n        return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n\n    def get_parent_path(self, **kwargs: Any) -&gt; str:\n        \"\"\"\n        Generate parent path using input parameters\n\n        Params:\n            **kwargs: Input parameters that maps template fields to values. They are used in the order of\n                      parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                      updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                      an error will be raised.\n\n        Returns:\n            Parent path string.\n        \"\"\"\n\n        # remove all fields not present in parent template\n        parent_fields = self.fields.copy()\n        fields_names = get_template_fields_names(self.template)\n        parent_fields_names = get_template_fields_names(self.parent_template)\n\n        # Drop fields corresponding to filename\n        for field in fields_names:\n            if field not in parent_fields_names:\n                parent_fields.pop(field)\n\n        # Make dynamic the parent path creation, so the last fields can be omitted\n        # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n        new_parent_template = self.parent_template\n        dynamic_fields_names = []\n        missing_kwarg_name = None\n        for parent_field_name in parent_fields_names:\n            is_optional = parent_fields[parent_field_name].is_optional\n            if parent_field_name not in kwargs and not is_optional:\n                # keep known (left) part of parent_template and drop the rest\n                missing_kwarg_name = parent_field_name\n                new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n                break\n            dynamic_fields_names.append(parent_field_name)\n\n        # Drop fields corresponding to last arguments that were skipped\n        parent_fields_names = list(parent_fields.keys())\n        for field_name in parent_fields_names:\n            if field_name not in dynamic_fields_names:\n                parent_fields.pop(field_name)\n\n        # Check for unnecessary extra args\n        extra_kwargs = {}\n        for field_name in kwargs:\n            if field_name not in parent_fields:\n                extra_kwargs[field_name] = kwargs[field_name]\n        if missing_kwarg_name and extra_kwargs:\n            raise ValueError(\n                f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n                f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n            )\n\n        return self._get_path(\n            template=new_parent_template,\n            fields_conf=parent_fields,\n            fields_values_dict=kwargs,\n        )\n\n    def assert_path_bijection(self, test_path: str):\n        \"\"\"\n        Assert path bijection\n\n        It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n        Params:\n            test_path: Path string to be tested\n        \"\"\"\n        parsed_fields = self.parse_path(test_path, raise_error=True)\n        result_test_path = self.get_path(**parsed_fields)\n        assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n\n    def assert_fields_bijection(self, test_fields: dict[str, Any]):\n        \"\"\"\n        Assert fields bijection\n\n        It tries to recover the same initial input after processing once with get_path and parse_file_path\n        This method is the preferred way of checking if the PathModel was well-defined.\n\n        Params:\n            test_fields: Dictionary of fields to be tested\n        \"\"\"\n        test_path = self.get_path(**test_fields)\n        result_parsed_fields = self.parse_path(test_path, raise_error=True)\n        assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.assert_fields_bijection","title":"<code>assert_fields_bijection(test_fields)</code>","text":"<p>Assert fields bijection</p> <p>It tries to recover the same initial input after processing once with get_path and parse_file_path This method is the preferred way of checking if the PathModel was well-defined.</p> <p>Parameters:</p> Name Type Description Default <code>test_fields</code> <code>dict[str, Any]</code> <p>Dictionary of fields to be tested</p> required Source code in <code>andar/path_model.py</code> <pre><code>def assert_fields_bijection(self, test_fields: dict[str, Any]):\n    \"\"\"\n    Assert fields bijection\n\n    It tries to recover the same initial input after processing once with get_path and parse_file_path\n    This method is the preferred way of checking if the PathModel was well-defined.\n\n    Params:\n        test_fields: Dictionary of fields to be tested\n    \"\"\"\n    test_path = self.get_path(**test_fields)\n    result_parsed_fields = self.parse_path(test_path, raise_error=True)\n    assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.assert_path_bijection","title":"<code>assert_path_bijection(test_path)</code>","text":"<p>Assert path bijection</p> <p>It tries to recover the same initial input after processing once with parse_file_path and get_path</p> <p>Parameters:</p> Name Type Description Default <code>test_path</code> <code>str</code> <p>Path string to be tested</p> required Source code in <code>andar/path_model.py</code> <pre><code>def assert_path_bijection(self, test_path: str):\n    \"\"\"\n    Assert path bijection\n\n    It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n    Params:\n        test_path: Path string to be tested\n    \"\"\"\n    parsed_fields = self.parse_path(test_path, raise_error=True)\n    result_test_path = self.get_path(**parsed_fields)\n    assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.get_parent_path","title":"<code>get_parent_path(**kwargs)</code>","text":"<p>Generate parent path using input parameters</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Input parameters that maps template fields to values. They are used in the order of       parent_template, if the last argument(s) are omitted, the parent_template will be dynamically       updated to a shorter version. If an argument in the middle is omitted, and it is not optional,       an error will be raised.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Parent path string.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_parent_path(self, **kwargs: Any) -&gt; str:\n    \"\"\"\n    Generate parent path using input parameters\n\n    Params:\n        **kwargs: Input parameters that maps template fields to values. They are used in the order of\n                  parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                  updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                  an error will be raised.\n\n    Returns:\n        Parent path string.\n    \"\"\"\n\n    # remove all fields not present in parent template\n    parent_fields = self.fields.copy()\n    fields_names = get_template_fields_names(self.template)\n    parent_fields_names = get_template_fields_names(self.parent_template)\n\n    # Drop fields corresponding to filename\n    for field in fields_names:\n        if field not in parent_fields_names:\n            parent_fields.pop(field)\n\n    # Make dynamic the parent path creation, so the last fields can be omitted\n    # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n    new_parent_template = self.parent_template\n    dynamic_fields_names = []\n    missing_kwarg_name = None\n    for parent_field_name in parent_fields_names:\n        is_optional = parent_fields[parent_field_name].is_optional\n        if parent_field_name not in kwargs and not is_optional:\n            # keep known (left) part of parent_template and drop the rest\n            missing_kwarg_name = parent_field_name\n            new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n            break\n        dynamic_fields_names.append(parent_field_name)\n\n    # Drop fields corresponding to last arguments that were skipped\n    parent_fields_names = list(parent_fields.keys())\n    for field_name in parent_fields_names:\n        if field_name not in dynamic_fields_names:\n            parent_fields.pop(field_name)\n\n    # Check for unnecessary extra args\n    extra_kwargs = {}\n    for field_name in kwargs:\n        if field_name not in parent_fields:\n            extra_kwargs[field_name] = kwargs[field_name]\n    if missing_kwarg_name and extra_kwargs:\n        raise ValueError(\n            f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n            f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n        )\n\n    return self._get_path(\n        template=new_parent_template,\n        fields_conf=parent_fields,\n        fields_values_dict=kwargs,\n    )\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.get_path","title":"<code>get_path(**kwargs)</code>","text":"<p>Generate path using input parameters</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Input parameters that maps template fields to values.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A path string.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_path(self, **kwargs: Any) -&gt; str:\n    \"\"\"\n    Generate path using input parameters\n\n    Params:\n        **kwargs: Input parameters that maps template fields to values.\n\n    Returns:\n        A path string.\n    \"\"\"\n    return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.parse_path","title":"<code>parse_path(file_path, raise_error=False)</code>","text":"<p>Parse a file path</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>String to be parsed.</p> required <code>raise_error</code> <code>bool</code> <p>Whether to raise an exception if the file path is not valid. By default, it returns None.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str:Any]</code> <p>Dictionary where each key represent a field of the template and each value is the corresponding parsed</p> <code>dict[str:Any]</code> <p>string (or converted object)</p> Source code in <code>andar/path_model.py</code> <pre><code>def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n    \"\"\"\n    Parse a file path\n\n    Params:\n        file_path: String to be parsed.\n        raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n\n    Returns:\n        Dictionary where each key represent a field of the template and each value is the corresponding parsed\n        string (or converted object)\n    \"\"\"\n\n    match = self.compiled_regex.match(file_path)\n    if not match:\n        if raise_error:\n            raise ValueError(f\"Invalid path '{file_path}', expected pattern: '{self.compiled_regex.pattern}'\")\n        return None\n    parsed_fields_dict = match.groupdict()\n    parsed_fields_dict = fusion_deduplicated_fields(parsed_fields_dict)\n\n    processed_fields = process_parsed_fields_values(self.fields, parsed_fields_dict)\n    return processed_fields\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.replace","title":"<code>replace(copy_description=False, **kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Attributes to be replaced, same arguments as used for PathModel instantiation</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def replace(self, copy_description: bool = False, **kwargs: Any) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    Params:\n        **kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n\n    Returns:\n        A PathModel instance\n    \"\"\"\n    default_parent_template = None  # default value when a new template is given, if not it reuse a previous one\n    if \"template\" not in kwargs:\n        kwargs[\"template\"] = self.template\n        default_parent_template = self._parent_template\n    if \"parent_template\" not in kwargs:\n        kwargs[\"parent_template\"] = default_parent_template  # reset to None when a new template is set\n    if \"fields\" not in kwargs:\n        kwargs[\"fields\"] = self._fields\n    if \"default_field\" not in kwargs:\n        kwargs[\"default_field\"] = self._default_field\n    default_description = None\n    if copy_description:\n        default_description = self._description\n    if \"description\" not in kwargs:\n        kwargs[\"description\"] = default_description\n\n    return self.__class__(**kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.update","title":"<code>update(**kwargs)</code>","text":"<p>Creates a copy of the current object updating attributes with the given keyword arguments</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Attributes to be updated, same arguments as used for PathModel instantiation.       Fields set to <code>None</code> will be reset to default_field, if no longer present in the template,       they will be removed instead.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def update(self, **kwargs: Any) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object updating attributes with the given keyword arguments\n\n    Params:\n        **kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                  Fields set to `None` will be reset to default_field, if no longer present in the template,\n                  they will be removed instead.\n\n    Returns:\n        A PathModel instance\n    \"\"\"\n    fields = self.fields.copy()\n    if \"fields\" in kwargs:\n        fields.update(kwargs[\"fields\"])\n        fields_names = list(fields.keys())\n        [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n        kwargs[\"fields\"] = fields\n    return self.replace(**kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.SafePatterns","title":"<code>SafePatterns</code>","text":"<p>Non-greedy patterns</p> <p>Attributes:</p> Name Type Description <code>FIELD</code> <p>Alphanumeric characters</p> <code>NAME</code> <p>Alphanumeric characters plus name separators: <code>-_.</code></p> <code>DIRPATH</code> <p>Alphanumeric characters plus name separators: <code>-_.</code> plus directory separator: <code>/</code></p> <code>EXTENSION</code> <p>Alphanumeric characters plus dots for sub extensions as in <code>tar.gz</code></p> Source code in <code>andar/field_conf.py</code> <pre><code>class SafePatterns:\n    \"\"\"\n    Non-greedy patterns\n\n    Attributes:\n        FIELD: Alphanumeric characters\n        NAME: Alphanumeric characters plus name separators: `-_.`\n        DIRPATH: Alphanumeric characters plus name separators: `-_.` plus directory separator: `/`\n        EXTENSION: Alphanumeric characters plus dots for sub extensions as in `tar.gz`\n    \"\"\"\n\n    FIELD = r\"[a-zA-Z0-9]+?\"  # without separator characters\n    NAME = r\"[-_.a-zA-Z0-9]+?\"  # include name separators: -_.\n    DIRPATH = r\"[-_.a-zA-Z0-9/]+?\"  # include name separators: -_. and directory separator: /\n    EXTENSION = r\"[.a-zA-Z0-9]+?\"  # include dots for sub extensions as 'tar.gz'\n</code></pre>"},{"location":"reference/andar/check_utils/","title":"check_utils","text":""},{"location":"reference/andar/check_utils/#andar.check_utils","title":"<code>andar.check_utils</code>","text":""},{"location":"reference/andar/check_utils/#andar.check_utils.check_expected_fields","title":"<code>check_expected_fields(expected_field_names, new_field_names)</code>","text":"<p>Check if fields in the expected_field_names are coherent with new_field_names</p> <p>Parameters:</p> Name Type Description Default <code>expected_field_names</code> <code>list[str]</code> <p>The expected list of field names.</p> required <code>new_field_names</code> <code>list[str]</code> <p>The new list of field names to be validated.</p> required Source code in <code>andar/check_utils.py</code> <pre><code>def check_expected_fields(expected_field_names: list[str], new_field_names: list[str]) -&gt; None:\n    \"\"\"\n    Check if fields in the expected_field_names are coherent with new_field_names\n\n    Params:\n        expected_field_names: The expected list of field names.\n        new_field_names: The new list of field names to be validated.\n    \"\"\"\n    invalid_fields = [f for f in new_field_names if f not in expected_field_names]\n    if invalid_fields:\n        raise ValueError(\n            f\"Invalid fields: {invalid_fields} they do not exist in expected field list: '{expected_field_names}'\"\n        )\n\n    missing_fields = [f for f in expected_field_names if f not in new_field_names]\n    if missing_fields:\n        raise ValueError(\n            f\"Missing fields: {missing_fields} they are required in expected field list: '{expected_field_names}'\"\n        )\n</code></pre>"},{"location":"reference/andar/check_utils/#andar.check_utils.check_parent_path_template","title":"<code>check_parent_path_template(path_template, parent_path_template)</code>","text":"<p>Check if parent_path_template is coherent with path_template</p> <p>Parameters:</p> Name Type Description Default <code>path_template</code> <code>str</code> <p>String. Path template that follows string.Formatter() syntax.</p> required <code>parent_path_template</code> <code>str</code> <p>String. Parent path template that follows string.Formatter() syntax.</p> required Source code in <code>andar/check_utils.py</code> <pre><code>def check_parent_path_template(path_template: str, parent_path_template: str) -&gt; None:\n    \"\"\"\n    Check if parent_path_template is coherent with path_template\n\n    Params:\n        path_template: String. Path template that follows string.Formatter() syntax.\n        parent_path_template: String. Parent path template that follows string.Formatter() syntax.\n    \"\"\"\n    if parent_path_template not in path_template:\n        raise ValueError(\n            f\"path_template: '{path_template}' does not match with parent_path_template: \"\n            f\"'{parent_path_template}'. parent_path_template must be a substring of path_template\"\n        )\n</code></pre>"},{"location":"reference/andar/examples/","title":"examples","text":""},{"location":"reference/andar/examples/#andar.examples","title":"<code>andar.examples</code>","text":""},{"location":"reference/andar/examples/path_model_examples/","title":"path_model_examples","text":""},{"location":"reference/andar/examples/path_model_examples/#andar.examples.path_model_examples","title":"<code>andar.examples.path_model_examples</code>","text":"<p>Docstring for andar.examples.path_model_examples</p> <p>Attributes:</p> Name Type Description <code>date_archived_pm</code> <code>PathModel</code> <p>A date archived path model.</p> <code>data_mesh_pm</code> <code>PathModel</code> <p>A data mesh path model.</p>"},{"location":"reference/andar/field_conf/","title":"field_conf","text":""},{"location":"reference/andar/field_conf/#andar.field_conf","title":"<code>andar.field_conf</code>","text":""},{"location":"reference/andar/field_conf/#andar.field_conf.FieldConf","title":"<code>FieldConf</code>  <code>dataclass</code>","text":"<p>FieldConf allows to configure how a path field is validated, parsed and processed</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>Regex pattern used to validate the input of get_path and get_parent_path, and also to get fields      using PathModel.parse_path(). By default, it used SafePatterns.NAME.</p> <code>NAME</code> <code>description</code> <code>str | None</code> <p>String used as documentation for the FieldConf.</p> <code>None</code> <code>date_format</code> <code>str | None</code> <p>date_format and datetime_format are used in get_path and get_parent_path for accepting either a             string or a datetime object that can be formated to an input string for a the given template.             They are also used for validating the parsed field when using parse_path and for defining how             to cast the string (to date or to datetime, depending on the argument that was used).</p> <code>None</code> <code>datetime_format</code> <code>str | None</code> <p>See description of date_format parameter.</p> <code>None</code> <code>is_optional</code> <code>bool | None</code> <p>allows to omit a field during the path generation (get_path and get_parent_path)             or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must             be constrained, otherwise the PathModel class may have an unexpected behaviour.             For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.</p> <code>None</code> Source code in <code>andar/field_conf.py</code> <pre><code>@dataclass\nclass FieldConf:\n    \"\"\"\n    FieldConf allows to configure how a path field is validated, parsed and processed\n\n    Params:\n        pattern: Regex pattern used to validate the input of get_path and get_parent_path, and also to get fields\n                 using PathModel.parse_path(). By default, it used SafePatterns.NAME.\n        description: String used as documentation for the FieldConf.\n        date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a\n                        string or a datetime object that can be formated to an input string for a the given template.\n                        They are also used for validating the parsed field when using parse_path and for defining how\n                        to cast the string (to date or to datetime, depending on the argument that was used).\n        datetime_format: See description of date_format parameter.\n        is_optional: allows to omit a field during the path generation (get_path and get_parent_path)\n                        or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must\n                        be constrained, otherwise the PathModel class may have an unexpected behaviour.\n                        For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.\n    \"\"\"\n\n    pattern: str = SafePatterns.NAME\n    description: str | None = None\n    date_format: str | None = None\n    datetime_format: str | None = None\n    is_optional: bool | None = None\n    str_to_var: Callable | None = None\n    var_to_str: Callable | None = None\n\n    def __post_init__(self):\n        has_date_converter = self.date_format is not None\n        has_datetime_converter = self.datetime_format is not None\n        has_custom_converter = self.var_to_str is not None or self.str_to_var is not None\n        active_converters_num = sum([has_date_converter, has_datetime_converter, has_custom_converter])\n        if active_converters_num &gt; 1:\n            raise ValueError(f\"Maximum one field converter is allowed, but {active_converters_num} were found\")\n\n    def __repr__(self):\n        formatted_fields = []\n        for k, v in vars(self).items():\n            if v is None:\n                continue\n            v_str = f\"'{v}'\" if isinstance(v, str) else v.__qualname__\n            field_str = f\"{k}={v_str}\"\n            formatted_fields.append(field_str)\n        formatted_fields_str = \", \".join(formatted_fields)\n        repr = f\"FieldConf({formatted_fields_str})\"\n        return repr\n\n    def replace(self, **kwargs: Any) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        Params:\n            **kwargs: Attributes (parameters) to be replaced\n\n        Returns:\n            A copy of the object with the attributes replaced\n        \"\"\"\n        field_conf = replace(self, **kwargs)\n        return field_conf\n</code></pre>"},{"location":"reference/andar/field_conf/#andar.field_conf.FieldConf.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Attributes (parameters) to be replaced</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A copy of the object with the attributes replaced</p> Source code in <code>andar/field_conf.py</code> <pre><code>def replace(self, **kwargs: Any) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    Params:\n        **kwargs: Attributes (parameters) to be replaced\n\n    Returns:\n        A copy of the object with the attributes replaced\n    \"\"\"\n    field_conf = replace(self, **kwargs)\n    return field_conf\n</code></pre>"},{"location":"reference/andar/field_conf/#andar.field_conf.SafePatterns","title":"<code>SafePatterns</code>","text":"<p>Non-greedy patterns</p> <p>Attributes:</p> Name Type Description <code>FIELD</code> <p>Alphanumeric characters</p> <code>NAME</code> <p>Alphanumeric characters plus name separators: <code>-_.</code></p> <code>DIRPATH</code> <p>Alphanumeric characters plus name separators: <code>-_.</code> plus directory separator: <code>/</code></p> <code>EXTENSION</code> <p>Alphanumeric characters plus dots for sub extensions as in <code>tar.gz</code></p> Source code in <code>andar/field_conf.py</code> <pre><code>class SafePatterns:\n    \"\"\"\n    Non-greedy patterns\n\n    Attributes:\n        FIELD: Alphanumeric characters\n        NAME: Alphanumeric characters plus name separators: `-_.`\n        DIRPATH: Alphanumeric characters plus name separators: `-_.` plus directory separator: `/`\n        EXTENSION: Alphanumeric characters plus dots for sub extensions as in `tar.gz`\n    \"\"\"\n\n    FIELD = r\"[a-zA-Z0-9]+?\"  # without separator characters\n    NAME = r\"[-_.a-zA-Z0-9]+?\"  # include name separators: -_.\n    DIRPATH = r\"[-_.a-zA-Z0-9/]+?\"  # include name separators: -_. and directory separator: /\n    EXTENSION = r\"[.a-zA-Z0-9]+?\"  # include dots for sub extensions as 'tar.gz'\n</code></pre>"},{"location":"reference/andar/parser_utils/","title":"parser_utils","text":""},{"location":"reference/andar/parser_utils/#andar.parser_utils","title":"<code>andar.parser_utils</code>","text":"<p>Module containing utility functions</p>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.assign_groupname_pattern_dict","title":"<code>assign_groupname_pattern_dict(pattern_dict)</code>","text":"<p>Assign a group name to each regex pattern present in the given dictionary</p> <p>Parameters:</p> Name Type Description Default <code>pattern_dict</code> <code>dict[str:str]</code> <p>A dictionary of regex patterns, where each key will be used as group name. It does not       check if the pattern already have a group name assign.</p> required <p>Returns:</p> Type Description <code>dict[str:str]</code> <p>A dictionary where the patterns have been assigned a group name.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def assign_groupname_pattern_dict(pattern_dict: dict[str:str]) -&gt; dict[str:str]:\n    \"\"\"\n    Assign a group name to each regex pattern present in the given dictionary\n\n    Params:\n        pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not\n                  check if the pattern already have a group name assign.\n\n    Returns:\n        A dictionary where the patterns have been assigned a group name.\n    \"\"\"\n    named_pattern_dict = {}\n    for field, pattern in pattern_dict.items():\n        named_pattern_dict[field] = f\"(?P&lt;{field}&gt;{pattern})\"\n    return named_pattern_dict\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.compile_path_regex","title":"<code>compile_path_regex(template, fields, ds='/')</code>","text":"<p>Compile a regex pattern using a path template and a FieldConf dictionary</p> Example <pre><code>filename_template = \"{prefix}_{name}.{extension}\"\nfields = {\n    \"prefix\": FieldConf(pattern=r\"[0-9]{4}\"),\n    \"name\": FieldConf(pattern=r\"[a-zA-Z0-9]+\"),\n    \"extension\": FieldConf(pattern=r\"json\")\n}\nfilename = \"0001_example.json\"\ncompiled_regex = compile_path_regex(filename_template, fields)\ncompiled_regex.match(filename).groupdict()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>str</code> <p>A path template that follows <code>PathModel.template</code> syntax.</p> required <code>fields</code> <code>dict[str:FieldConf]</code> <p>A dictionary where each key represent a field of the template and each value represent its corresponding     <code>FieldConf()</code>.</p> required <code>ds</code> <code>str</code> <p>Directory separator string.</p> <code>'/'</code> <p>Returns:</p> Type Description <code>Pattern</code> <p>A compiled regex pattern.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def compile_path_regex(template: str, fields: dict[str:FieldConf], ds: str = \"/\") -&gt; re.Pattern:\n    \"\"\"\n    Compile a regex pattern using a path template and a FieldConf dictionary\n\n    Example:\n        ```python\n        filename_template = \"{prefix}_{name}.{extension}\"\n        fields = {\n            \"prefix\": FieldConf(pattern=r\"[0-9]{4}\"),\n            \"name\": FieldConf(pattern=r\"[a-zA-Z0-9]+\"),\n            \"extension\": FieldConf(pattern=r\"json\")\n        }\n        filename = \"0001_example.json\"\n        compiled_regex = compile_path_regex(filename_template, fields)\n        compiled_regex.match(filename).groupdict()\n        ```\n\n    Params:\n        template: A path template that follows `PathModel.template` syntax.\n        fields: A dictionary where each key represent a field of the template and each value represent its corresponding\n                `FieldConf()`.\n        ds: Directory separator string.\n\n    Returns:\n        A compiled regex pattern.\n    \"\"\"\n    template_field_names = get_template_fields_names(template)\n    field_names = list(fields.keys())\n    check_expected_fields(template_field_names, field_names)\n\n    invalid_fields = [n for n in field_names if n.find(\"__\") &gt;= 0]\n\n    if len(invalid_fields) &gt; 0:\n        raise ValueError(f\"Fields cannot contains double underscore: {invalid_fields}\")\n\n    template = template.replace(r\".\", r\"\\.\")\n    pattern_dict = {}\n    for field_name, field_conf in fields.items():\n        field_pattern = field_conf.pattern\n        if field_conf.is_optional:\n            field_pattern = f\"{field_pattern}|\"\n            # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n            field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n            optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n            template = template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n        pattern_dict[field_name] = field_pattern\n\n    # Deduplicate repeated fields of pattern_dict:\n    # for example the template \"{base_path}/{asset_name}/{asset_name}_{suffix}\"\n    # will become \"{base_path}/{asset_name__0}/{asset_name__1}_{suffix}\"\n    # and the dict {\"base_path\": r\"\\w+\", \"asset_name\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    # will become {\"base_path\": r\"\\w+\", \"asset_name__0\": r\"\\w+\", \"asset_name__1\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    unique_fields = list(set(template_field_names))\n    new_pattern_dict = {}\n    new_template = template\n    for field_name in unique_fields:\n        field_count = len([f for f in template_field_names if f == field_name])\n        if field_count == 1:\n            new_pattern_dict[field_name] = pattern_dict[field_name]\n            continue\n        for idx in range(field_count):\n            new_field_name = field_name + f\"__{idx}\"\n            new_pattern_dict[new_field_name] = pattern_dict[field_name]\n            new_template = new_template.replace(\"{\" + field_name + \"}\", \"{\" + new_field_name + \"}\", 1)\n\n    has_duplicates = pattern_dict != new_pattern_dict\n    if has_duplicates:\n        pattern_dict = new_pattern_dict\n        template = new_template\n\n    # Build full pattern string\n    named_pattern_dict = assign_groupname_pattern_dict(pattern_dict)\n    path_pattern = template.format(**named_pattern_dict)\n    path_pattern = f\"^{path_pattern}$\"  # match the full string\n    compiled_pattern = re.compile(path_pattern)\n    return compiled_pattern\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.fusion_deduplicated_fields","title":"<code>fusion_deduplicated_fields(parsed_field_dict)</code>","text":"<p>Fusion deduplicated fields in a parsed field dict</p> Example <pre><code>deduplicated_field_dict = {\n    \"name\": \"data\",\n    \"version__0\": \"v1\",\n    \"version__1\": \"v1\",\n    \"ext\": \"csv\",\n}\nfusioned_field_dict = fusion_deduplicated_fields(deduplicated_field_dict)\n# {\n#     \"name\": \"data\",\n#     \"version\": \"v1\",\n#     \"ext\": \"csv\",\n# }\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>parsed_field_dict</code> <code>dict[str, str]</code> <p>A dictionary where each key represent a field name. A deduplicated field will have a                suffix <code>__{id}</code>.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary where deduplicated fields are fusioned in a single field with the suffix removed.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def fusion_deduplicated_fields(parsed_field_dict: dict[str, str]) -&gt; dict[str, str]:\n    \"\"\"\n    Fusion deduplicated fields in a parsed field dict\n\n    Example:\n        ```python\n        deduplicated_field_dict = {\n            \"name\": \"data\",\n            \"version__0\": \"v1\",\n            \"version__1\": \"v1\",\n            \"ext\": \"csv\",\n        }\n        fusioned_field_dict = fusion_deduplicated_fields(deduplicated_field_dict)\n        # {\n        #     \"name\": \"data\",\n        #     \"version\": \"v1\",\n        #     \"ext\": \"csv\",\n        # }\n        ```\n\n    Params:\n        parsed_field_dict: A dictionary where each key represent a field name. A deduplicated field will have a\n                           suffix `__{id}`.\n\n    Returns:\n        A dictionary where deduplicated fields are fusioned in a single field with the suffix removed.\n    \"\"\"\n\n    deduplicated_regex = re.compile(r\"^(?P&lt;name&gt;.+?)__(?P&lt;id&gt;\\d)$\")\n\n    deduplicated_fields_dict = {}\n\n    for field_name in parsed_field_dict:\n        match = deduplicated_regex.match(field_name)\n        if match is None:\n            continue\n        match_dict = match.groupdict()\n        original_field_name = match_dict[\"name\"]\n        if original_field_name not in deduplicated_fields_dict:\n            deduplicated_fields_dict[original_field_name] = []\n        deduplicated_fields_dict[original_field_name].append(field_name)\n\n    # Fusion deduplicated fields:\n    # it will raise an error if the deduplicate fields have multiples values\n    # for example this parsed dict will raise an error because asset_name__0 and asset_name__1 should be equal:\n    # {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"other_asset\", \"suffix\": \"001\"}\n    # if the deduplicated fields are coherent they will be fusion and renamed to its original name:\n    # for example {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"my_asset\", \"suffix\": \"001\"}\n    # to {\"base_path\": \"folder\", \"asset_name\": \"my_asset\", \"suffix\": \"001\"}\n    for original_field_name, deduplicated_list in deduplicated_fields_dict.items():\n        parsed_field_values = [parsed_field_dict.pop(f) for f in deduplicated_list]\n        unique_parsed_field_values = list(set(parsed_field_values))\n        are_duplicated_unique = len(unique_parsed_field_values) == 1\n        if not are_duplicated_unique:\n            raise ValueError(\n                f\"More than one value was found for repeated field '{original_field_name}': {parsed_field_values}\"\n            )\n        parsed_field_dict[original_field_name] = unique_parsed_field_values[0]\n    return parsed_field_dict\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.get_template_fields_names","title":"<code>get_template_fields_names(path_template)</code>","text":"<p>Get fields names from path template string</p> <p>Parameters:</p> Name Type Description Default <code>path_template</code> <code>str</code> <p>Path template that follows string.Formatter() syntax.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Template fields names.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def get_template_fields_names(path_template: str) -&gt; list[str]:\n    \"\"\"\n    Get fields names from path template string\n\n    Params:\n        path_template: Path template that follows string.Formatter() syntax.\n\n    Returns:\n        Template fields names.\n    \"\"\"\n    parsed_field_tuples = list(string.Formatter().parse(path_template))\n    template_fields_names = [name for (text, name, spec, conv) in parsed_field_tuples if name is not None]\n    return template_fields_names\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.prepare_fields_values","title":"<code>prepare_fields_values(fields_values_dict, fields_conf)</code>","text":"<p>Prepare fields values for this path</p> <p>Parameters:</p> Name Type Description Default <code>fields_values_dict</code> <code>dict[str, Any]</code> <p>Dictionary of fields values</p> required <code>fields_conf</code> <code>dict[str, FieldConf]</code> <p>Dictionary of fields configuration (i.e.class FieldConf)</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of fields where the values were converted to strings.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def prepare_fields_values(fields_values_dict: dict[str, Any], fields_conf: dict[str, FieldConf]) -&gt; dict[str, str]:\n    \"\"\"\n    Prepare fields values for this path\n\n    Params:\n        fields_values_dict: Dictionary of fields values\n        fields_conf: Dictionary of fields configuration (i.e.class FieldConf)\n\n    Returns:\n        A dictionary of fields where the values were converted to strings.\n    \"\"\"\n    new_fields_values_dict = {}\n    for field_name, field_value in fields_values_dict.items():\n        if field_name not in fields_conf:\n            print(f\"skipping field '{field_name}'\")\n            continue\n        field_conf = fields_conf[field_name]\n\n        if field_value is None and field_conf.is_optional:\n            new_fields_values_dict[field_name] = \"\"\n            continue\n\n        if field_conf.date_format is not None:\n            new_field_value = field_value.strftime(field_conf.date_format)\n        elif field_conf.datetime_format is not None:\n            new_field_value = field_value.strftime(field_conf.datetime_format)\n        elif field_conf.var_to_str is not None:\n            new_field_value = field_conf.var_to_str(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        result = re.match(field_pattern, new_field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{new_field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n        new_fields_values_dict[field_name] = new_field_value\n    return new_fields_values_dict\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.process_parsed_fields_values","title":"<code>process_parsed_fields_values(fields_conf, parsed_fields)</code>","text":"<p>Process fields values dictionary obtained from parsing a file path</p> <p>Parameters:</p> Name Type Description Default <code>parsed_fields</code> <code>dict[str, str]</code> <p>A dictionary of parsed fields values in string format.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A processed dictionary of fields with converted values depending on each FieldConf definition.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def process_parsed_fields_values(fields_conf: dict[str, FieldConf], parsed_fields: dict[str, str]) -&gt; dict[str, Any]:\n    \"\"\"\n    Process fields values dictionary obtained from parsing a file path\n\n    Params:\n        parsed_fields: A dictionary of parsed fields values in string format.\n\n    Returns:\n        A processed dictionary of fields with converted values depending on each FieldConf definition.\n    \"\"\"\n    new_parsed_fields = parsed_fields.copy()\n\n    for field_name, field_value in new_parsed_fields.items():\n        if field_name not in fields_conf:\n            raise ValueError(f\"Unknown field '{field_name}'. Valid fields are: {fields_conf.keys()}\")\n        field_conf = fields_conf[field_name]\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        if field_conf.is_optional:\n            field_pattern = f\"^{field_conf.pattern}|$\"\n        result = re.match(field_pattern, field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n\n        if field_conf.date_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.date_format).date()\n        elif field_conf.datetime_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.datetime_format)\n        elif field_conf.str_to_var is not None:\n            new_field_value = field_conf.str_to_var(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        if new_field_value == \"\" and field_conf.is_optional:\n            new_field_value = None\n\n        new_parsed_fields[field_name] = new_field_value\n    return new_parsed_fields\n</code></pre>"},{"location":"reference/andar/path_model/","title":"path_model","text":""},{"location":"reference/andar/path_model/#andar.path_model","title":"<code>andar.path_model</code>","text":""},{"location":"reference/andar/path_model/#andar.path_model.PathModel","title":"<code>PathModel</code>","text":"<p>PathModel allows to define, build and parse templated file paths</p> <p>It defines a path via a template and its fields. Once instantiated, it allows to build new paths and to parse path strings to recover individual fields.</p> <p>Attributes:</p> Name Type Description <code>template</code> <code>str</code> <p>A template string</p> <code>fields</code> <code>dict[str, FieldConf]</code> <p>A dictionary of FieldConfs</p> Source code in <code>andar/path_model.py</code> <pre><code>class PathModel:\n    \"\"\"\n    PathModel allows to define, build and parse templated file paths\n\n    It defines a path via a template and its fields. Once instantiated, it allows to build new paths\n    and to parse path strings to recover individual fields.\n\n    Attributes:\n        template: A template string\n        fields: A dictionary of FieldConfs\n    \"\"\"\n\n    template: str\n    fields: dict[str, FieldConf]\n    default_field: FieldConf\n    parent_template: str\n    description: str\n    compiled_regex: re.Pattern\n    _dir_sep: str = \"/\"\n\n    def __init__(\n        self,\n        template: str,\n        *,\n        fields: dict[str, FieldConf] | None = None,\n        default_field: FieldConf | None = None,\n        parent_template: str | None = None,\n        description: str | None = None,\n    ):\n        self.template = template\n        self._fields = fields\n        self._parent_template = parent_template\n        self._default_field = default_field\n        self._description = description\n\n        if parent_template is None:\n            parent_template = os.path.dirname(self.template)\n        check_parent_path_template(template, parent_template)\n        self.parent_template = parent_template\n\n        if default_field is None:\n            default_field = FieldConf()\n        self.default_field = default_field\n\n        new_fields = {}\n        template_field_names = get_template_fields_names(template)\n        for field_name in template_field_names:\n            new_fields[field_name] = default_field\n\n        if fields is not None:\n            new_fields.update(fields)\n        self.fields = new_fields\n\n        new_field_names = list(new_fields.keys())\n        check_expected_fields(template_field_names, new_field_names)\n\n        if description is None:\n            description = \"\"\n        self.description = description\n\n        self.compiled_regex = compile_path_regex(\n            template=self.template,\n            fields=self.fields,\n            ds=self._dir_sep,\n        )\n\n    def __repr__(self):\n        ident = \"  \"\n        formatted_fields = \"\\n\".join([f\"{ident * 2}'{k}': {v},\" for k, v in self.fields.items()])\n        formatted_args = [f\"{ident}template='{self.template}',\"]\n        if self._fields is not None:\n            formatted_args.append(f\"{ident}fields={{\\n{formatted_fields}\\n  }},\")\n        if self._default_field is not None:\n            formatted_args.append(f\"{ident}default_field={self.default_field},\")\n        if self._parent_template is not None:\n            formatted_args.append(f\"{ident}parent_template='{self.parent_template}',\")\n        if self._description is not None:\n            formatted_args.append(f\"{ident}description='{self.description}',\")\n        formatted_args_str = \"\\n\".join(formatted_args)\n        repr = f\"PathModel(\\n{formatted_args_str}\\n)\"\n        return repr\n\n    def replace(self, copy_description: bool = False, **kwargs: Any) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        Params:\n            **kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n\n        Returns:\n            A PathModel instance\n        \"\"\"\n        default_parent_template = None  # default value when a new template is given, if not it reuse a previous one\n        if \"template\" not in kwargs:\n            kwargs[\"template\"] = self.template\n            default_parent_template = self._parent_template\n        if \"parent_template\" not in kwargs:\n            kwargs[\"parent_template\"] = default_parent_template  # reset to None when a new template is set\n        if \"fields\" not in kwargs:\n            kwargs[\"fields\"] = self._fields\n        if \"default_field\" not in kwargs:\n            kwargs[\"default_field\"] = self._default_field\n        default_description = None\n        if copy_description:\n            default_description = self._description\n        if \"description\" not in kwargs:\n            kwargs[\"description\"] = default_description\n\n        return self.__class__(**kwargs)\n\n    def update(self, **kwargs: Any) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object updating attributes with the given keyword arguments\n\n        Params:\n            **kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                      Fields set to `None` will be reset to default_field, if no longer present in the template,\n                      they will be removed instead.\n\n        Returns:\n            A PathModel instance\n        \"\"\"\n        fields = self.fields.copy()\n        if \"fields\" in kwargs:\n            fields.update(kwargs[\"fields\"])\n            fields_names = list(fields.keys())\n            [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n            kwargs[\"fields\"] = fields\n        return self.replace(**kwargs)\n\n    def __call__(self, **kwargs) -&gt; Self:\n        if not kwargs:\n            return self\n        return self.replace(**kwargs)\n\n    def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n        \"\"\"\n        Parse a file path\n\n        Params:\n            file_path: String to be parsed.\n            raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n\n        Returns:\n            Dictionary where each key represent a field of the template and each value is the corresponding parsed\n            string (or converted object)\n        \"\"\"\n\n        match = self.compiled_regex.match(file_path)\n        if not match:\n            if raise_error:\n                raise ValueError(f\"Invalid path '{file_path}', expected pattern: '{self.compiled_regex.pattern}'\")\n            return None\n        parsed_fields_dict = match.groupdict()\n        parsed_fields_dict = fusion_deduplicated_fields(parsed_fields_dict)\n\n        processed_fields = process_parsed_fields_values(self.fields, parsed_fields_dict)\n        return processed_fields\n\n    @classmethod\n    def _get_path(\n        cls,\n        template: str,\n        fields_conf: dict[str, FieldConf],\n        fields_values_dict: dict[str, Any],\n    ) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        Params:\n            template: A template that follows string.Formatter() syntax.\n            fields_conf: Dictionary of fields configurations, where keys are field names and values are FieldConf\n                         instances.\n            fields_values_dict: Input parameters dict that maps template fields to values.\n\n        Returns:\n            A path string.\n        \"\"\"\n        fields_values_dict = fields_values_dict.copy()\n        template_field_names = get_template_fields_names(template)\n        missing_field_names = [field for field in template_field_names if field not in fields_values_dict]\n\n        for field_name in missing_field_names:\n            is_optional = fields_conf[field_name].is_optional\n            if is_optional:\n                fields_values_dict[field_name] = None\n\n        given_field_names = list(fields_values_dict.keys())\n        check_expected_fields(template_field_names, given_field_names)\n        fields_values_dict = prepare_fields_values(fields_values_dict, fields_conf)\n        new_path = template.format(**fields_values_dict)\n        new_path = os.path.normpath(new_path)\n        return new_path\n\n    def get_path(self, **kwargs: Any) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        Params:\n            **kwargs: Input parameters that maps template fields to values.\n\n        Returns:\n            A path string.\n        \"\"\"\n        return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n\n    def get_parent_path(self, **kwargs: Any) -&gt; str:\n        \"\"\"\n        Generate parent path using input parameters\n\n        Params:\n            **kwargs: Input parameters that maps template fields to values. They are used in the order of\n                      parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                      updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                      an error will be raised.\n\n        Returns:\n            Parent path string.\n        \"\"\"\n\n        # remove all fields not present in parent template\n        parent_fields = self.fields.copy()\n        fields_names = get_template_fields_names(self.template)\n        parent_fields_names = get_template_fields_names(self.parent_template)\n\n        # Drop fields corresponding to filename\n        for field in fields_names:\n            if field not in parent_fields_names:\n                parent_fields.pop(field)\n\n        # Make dynamic the parent path creation, so the last fields can be omitted\n        # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n        new_parent_template = self.parent_template\n        dynamic_fields_names = []\n        missing_kwarg_name = None\n        for parent_field_name in parent_fields_names:\n            is_optional = parent_fields[parent_field_name].is_optional\n            if parent_field_name not in kwargs and not is_optional:\n                # keep known (left) part of parent_template and drop the rest\n                missing_kwarg_name = parent_field_name\n                new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n                break\n            dynamic_fields_names.append(parent_field_name)\n\n        # Drop fields corresponding to last arguments that were skipped\n        parent_fields_names = list(parent_fields.keys())\n        for field_name in parent_fields_names:\n            if field_name not in dynamic_fields_names:\n                parent_fields.pop(field_name)\n\n        # Check for unnecessary extra args\n        extra_kwargs = {}\n        for field_name in kwargs:\n            if field_name not in parent_fields:\n                extra_kwargs[field_name] = kwargs[field_name]\n        if missing_kwarg_name and extra_kwargs:\n            raise ValueError(\n                f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n                f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n            )\n\n        return self._get_path(\n            template=new_parent_template,\n            fields_conf=parent_fields,\n            fields_values_dict=kwargs,\n        )\n\n    def assert_path_bijection(self, test_path: str):\n        \"\"\"\n        Assert path bijection\n\n        It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n        Params:\n            test_path: Path string to be tested\n        \"\"\"\n        parsed_fields = self.parse_path(test_path, raise_error=True)\n        result_test_path = self.get_path(**parsed_fields)\n        assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n\n    def assert_fields_bijection(self, test_fields: dict[str, Any]):\n        \"\"\"\n        Assert fields bijection\n\n        It tries to recover the same initial input after processing once with get_path and parse_file_path\n        This method is the preferred way of checking if the PathModel was well-defined.\n\n        Params:\n            test_fields: Dictionary of fields to be tested\n        \"\"\"\n        test_path = self.get_path(**test_fields)\n        result_parsed_fields = self.parse_path(test_path, raise_error=True)\n        assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.assert_fields_bijection","title":"<code>assert_fields_bijection(test_fields)</code>","text":"<p>Assert fields bijection</p> <p>It tries to recover the same initial input after processing once with get_path and parse_file_path This method is the preferred way of checking if the PathModel was well-defined.</p> <p>Parameters:</p> Name Type Description Default <code>test_fields</code> <code>dict[str, Any]</code> <p>Dictionary of fields to be tested</p> required Source code in <code>andar/path_model.py</code> <pre><code>def assert_fields_bijection(self, test_fields: dict[str, Any]):\n    \"\"\"\n    Assert fields bijection\n\n    It tries to recover the same initial input after processing once with get_path and parse_file_path\n    This method is the preferred way of checking if the PathModel was well-defined.\n\n    Params:\n        test_fields: Dictionary of fields to be tested\n    \"\"\"\n    test_path = self.get_path(**test_fields)\n    result_parsed_fields = self.parse_path(test_path, raise_error=True)\n    assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.assert_path_bijection","title":"<code>assert_path_bijection(test_path)</code>","text":"<p>Assert path bijection</p> <p>It tries to recover the same initial input after processing once with parse_file_path and get_path</p> <p>Parameters:</p> Name Type Description Default <code>test_path</code> <code>str</code> <p>Path string to be tested</p> required Source code in <code>andar/path_model.py</code> <pre><code>def assert_path_bijection(self, test_path: str):\n    \"\"\"\n    Assert path bijection\n\n    It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n    Params:\n        test_path: Path string to be tested\n    \"\"\"\n    parsed_fields = self.parse_path(test_path, raise_error=True)\n    result_test_path = self.get_path(**parsed_fields)\n    assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.get_parent_path","title":"<code>get_parent_path(**kwargs)</code>","text":"<p>Generate parent path using input parameters</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Input parameters that maps template fields to values. They are used in the order of       parent_template, if the last argument(s) are omitted, the parent_template will be dynamically       updated to a shorter version. If an argument in the middle is omitted, and it is not optional,       an error will be raised.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Parent path string.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_parent_path(self, **kwargs: Any) -&gt; str:\n    \"\"\"\n    Generate parent path using input parameters\n\n    Params:\n        **kwargs: Input parameters that maps template fields to values. They are used in the order of\n                  parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                  updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                  an error will be raised.\n\n    Returns:\n        Parent path string.\n    \"\"\"\n\n    # remove all fields not present in parent template\n    parent_fields = self.fields.copy()\n    fields_names = get_template_fields_names(self.template)\n    parent_fields_names = get_template_fields_names(self.parent_template)\n\n    # Drop fields corresponding to filename\n    for field in fields_names:\n        if field not in parent_fields_names:\n            parent_fields.pop(field)\n\n    # Make dynamic the parent path creation, so the last fields can be omitted\n    # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n    new_parent_template = self.parent_template\n    dynamic_fields_names = []\n    missing_kwarg_name = None\n    for parent_field_name in parent_fields_names:\n        is_optional = parent_fields[parent_field_name].is_optional\n        if parent_field_name not in kwargs and not is_optional:\n            # keep known (left) part of parent_template and drop the rest\n            missing_kwarg_name = parent_field_name\n            new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n            break\n        dynamic_fields_names.append(parent_field_name)\n\n    # Drop fields corresponding to last arguments that were skipped\n    parent_fields_names = list(parent_fields.keys())\n    for field_name in parent_fields_names:\n        if field_name not in dynamic_fields_names:\n            parent_fields.pop(field_name)\n\n    # Check for unnecessary extra args\n    extra_kwargs = {}\n    for field_name in kwargs:\n        if field_name not in parent_fields:\n            extra_kwargs[field_name] = kwargs[field_name]\n    if missing_kwarg_name and extra_kwargs:\n        raise ValueError(\n            f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n            f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n        )\n\n    return self._get_path(\n        template=new_parent_template,\n        fields_conf=parent_fields,\n        fields_values_dict=kwargs,\n    )\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.get_path","title":"<code>get_path(**kwargs)</code>","text":"<p>Generate path using input parameters</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Input parameters that maps template fields to values.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A path string.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_path(self, **kwargs: Any) -&gt; str:\n    \"\"\"\n    Generate path using input parameters\n\n    Params:\n        **kwargs: Input parameters that maps template fields to values.\n\n    Returns:\n        A path string.\n    \"\"\"\n    return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.parse_path","title":"<code>parse_path(file_path, raise_error=False)</code>","text":"<p>Parse a file path</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>String to be parsed.</p> required <code>raise_error</code> <code>bool</code> <p>Whether to raise an exception if the file path is not valid. By default, it returns None.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str:Any]</code> <p>Dictionary where each key represent a field of the template and each value is the corresponding parsed</p> <code>dict[str:Any]</code> <p>string (or converted object)</p> Source code in <code>andar/path_model.py</code> <pre><code>def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n    \"\"\"\n    Parse a file path\n\n    Params:\n        file_path: String to be parsed.\n        raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n\n    Returns:\n        Dictionary where each key represent a field of the template and each value is the corresponding parsed\n        string (or converted object)\n    \"\"\"\n\n    match = self.compiled_regex.match(file_path)\n    if not match:\n        if raise_error:\n            raise ValueError(f\"Invalid path '{file_path}', expected pattern: '{self.compiled_regex.pattern}'\")\n        return None\n    parsed_fields_dict = match.groupdict()\n    parsed_fields_dict = fusion_deduplicated_fields(parsed_fields_dict)\n\n    processed_fields = process_parsed_fields_values(self.fields, parsed_fields_dict)\n    return processed_fields\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.replace","title":"<code>replace(copy_description=False, **kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Attributes to be replaced, same arguments as used for PathModel instantiation</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def replace(self, copy_description: bool = False, **kwargs: Any) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    Params:\n        **kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n\n    Returns:\n        A PathModel instance\n    \"\"\"\n    default_parent_template = None  # default value when a new template is given, if not it reuse a previous one\n    if \"template\" not in kwargs:\n        kwargs[\"template\"] = self.template\n        default_parent_template = self._parent_template\n    if \"parent_template\" not in kwargs:\n        kwargs[\"parent_template\"] = default_parent_template  # reset to None when a new template is set\n    if \"fields\" not in kwargs:\n        kwargs[\"fields\"] = self._fields\n    if \"default_field\" not in kwargs:\n        kwargs[\"default_field\"] = self._default_field\n    default_description = None\n    if copy_description:\n        default_description = self._description\n    if \"description\" not in kwargs:\n        kwargs[\"description\"] = default_description\n\n    return self.__class__(**kwargs)\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.update","title":"<code>update(**kwargs)</code>","text":"<p>Creates a copy of the current object updating attributes with the given keyword arguments</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Attributes to be updated, same arguments as used for PathModel instantiation.       Fields set to <code>None</code> will be reset to default_field, if no longer present in the template,       they will be removed instead.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def update(self, **kwargs: Any) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object updating attributes with the given keyword arguments\n\n    Params:\n        **kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                  Fields set to `None` will be reset to default_field, if no longer present in the template,\n                  they will be removed instead.\n\n    Returns:\n        A PathModel instance\n    \"\"\"\n    fields = self.fields.copy()\n    if \"fields\" in kwargs:\n        fields.update(kwargs[\"fields\"])\n        fields_names = list(fields.keys())\n        [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n        kwargs[\"fields\"] = fields\n    return self.replace(**kwargs)\n</code></pre>"}]}