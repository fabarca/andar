{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Andar Package","text":"<p>Caminante, no hay camino, se hace camino al andar.</p> <p>Antonio Machado</p> <p>Andar is a python package that provides an abstraction layer for managing path structures, helping to create and parse paths in a programmatic way via templated file paths.</p>"},{"location":"#install-package","title":"Install Package","text":"<p>With pip: <pre><code>pip install andar\n</code></pre></p>"},{"location":"#quick-start","title":"Quick start:","text":"<p>Simple PathModel definition using default field configurations:</p> <pre><code>from andar import PathModel\n\nsimple_path_model = PathModel(\n    template=\"/{base_folder}/{subfolder}/{base_name}__{suffix}.{extension}\"\n)\n</code></pre> <p>Generate a path:</p> <pre><code>result_path = simple_path_model.get_path(\n    base_folder=\"parent_folder\",\n    subfolder=\"other_folder\",\n    base_name=\"mydata\",\n    suffix=\"2000-01-01\",\n    extension=\"csv\",\n)\nprint(result_path)\n</code></pre> <pre><code>\"/parent_folder/other_folder/mydata__2000-01-01.csv\"\n</code></pre> <p>Parse a path:</p> <pre><code>file_path = \"/data/reports/summary__2025-12-31.csv\"\nparsed_fields = simple_path_model.parse_path(file_path)\nprint(parsed_fields)\n</code></pre> <pre><code>{\n    'base_folder': 'data', \n    'subfolder': 'reports', \n    'base_name': 'summary', \n    'suffix': '2025-12-31', \n    'extension': 'csv',\n}\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#how-to-create-a-path-generator-parser-for-a-date-tree-structure","title":"How to create a path generator / parser for a date tree structure","text":"<p>Define a PathModel following a date tree folder structure with datetime a suffix using the next template and fields:</p> <pre><code>from andar import FieldConf, PathModel, SafePatterns\n\ndate_archived_pm = PathModel(\n    template=\"{base_path}/{subfolder}/{date_path}/{date_prefix}_{name}_{datetime_suffix}.{ext}\",\n    fields={\n        \"base_path\": FieldConf(pattern=SafePatterns.DIRPATH),\n        \"subfolder\": FieldConf(pattern=SafePatterns.NAME),\n        \"date_path\": FieldConf(pattern=r\"\\d{4}/\\d{2}/\\d{2}\", date_format=\"%Y/%m/%d\"),\n        \"date_prefix\": FieldConf(pattern=r\"\\d{4}-\\d{2}-\\d{2}\", date_format=\"%Y-%m-%d\"),\n        \"name\": FieldConf(pattern=SafePatterns.FIELD),\n        \"datetime_suffix\": FieldConf(pattern=r\"\\d{8}_\\d{6}\", datetime_format=\"%Y%m%d_%H%M%S\"),\n        \"ext\": FieldConf(pattern=SafePatterns.EXTENSION),\n    },\n)\n</code></pre> <p>Then, for generating the paths just iterate over dates:</p> <pre><code>import datetime as dt\n\nbase_path = \"/company/reports\"\nsubfolder = \"finance\"\nreport_name = \"revenue\"\nextension = \"xls\"\nstart_date = dt.date(2025, 12, 1)\nreport_date_list = [start_date + dt.timedelta(days=d) for d in range(10)]\n\nfor report_date in report_date_list:\n    creation_datetime = dt.datetime.now()\n    report_path = date_archived_pm.get_path(\n        base_path=base_path,\n        subfolder=subfolder,\n        date_path=report_date,\n        date_prefix=report_date,\n        name=report_name,\n        datetime_suffix=creation_datetime,\n        ext=extension,\n    )\n    print(report_path)\n</code></pre> <p>For parsing already existing paths use a library that allows to recursive search (e.g. pathlib, glob, os, etc)  and output a fullpath for each file:</p> <pre><code>import pathlib\nbase_path = \"/company/reports\"\nsearch_folder = pathlib.Path(base_path)\npath_list = [str(i) for i in search_folder.rglob(\"*\") if i.is_file()]\n\nfor file_path in path_list:\n    parsed_fields = date_archived_pm.parse_path(file_path)\n    print(parsed_fields)\n</code></pre>"},{"location":"#how-to-define-path-conventions-for-a-datalake","title":"How to define path conventions for a datalake","text":"<p>For example Data Mesh propose conventions for separating data into domains, layers and products.  This could be implemented with the following PathModel template and fields:</p> <pre><code>from andar import FieldConf, PathModel, SafePatterns\n\ndata_mesh_pm = PathModel(\n    template=\"/{domain}/{layer}/{product}/{aggregation}/{date}_{product}.{ext}\",\n    fields={\n        \"domain\": FieldConf(pattern=SafePatterns.NAME),  # sales, marketing, HR, finance, etc\n        \"layer\": FieldConf(pattern=SafePatterns.NAME),  # raw, intermediate, mart, etc\n        \"product\": FieldConf(pattern=SafePatterns.NAME),  # orders, revenues, taxes, campaigns, etc\n        \"aggregation\": FieldConf(pattern=SafePatterns.NAME),  # daily, weekly, monthly, etc\n        \"date\": FieldConf(pattern=r\"\\d{8}\", datetime_format=\"%Y%m%d\"),  # product date\n        \"ext\": FieldConf(pattern=SafePatterns.EXTENSION),  # csv, xls, parquet, etc\n    },\n)\n</code></pre> <p>For improving traceability, it's a good practice to also include run datetime (i.e. generation date)  as a simple version system: <pre><code>from andar import FieldConf, PathModel, SafePatterns\n\ndata_mesh_pm = PathModel(\n    template=\"/{domain}/{layer}/{product}/{aggregation}/{product_date}_{product}_{run_datetime}.{ext}\",\n    fields={\n        \"domain\": FieldConf(pattern=SafePatterns.NAME),  # sales, marketing, HR, finance, etc\n        \"layer\": FieldConf(pattern=SafePatterns.NAME),  # raw, intermediate, mart, etc\n        \"product\": FieldConf(pattern=SafePatterns.NAME),  # orders, revenues, taxes, campaigns, etc\n        \"aggregation\": FieldConf(pattern=SafePatterns.NAME),  # daily, weekly, monthly, etc\n        \"product_date\": FieldConf(pattern=r\"\\d{8}\", datetime_format=\"%Y%m%d\"),  # product target date\n        \"run_datetime\": FieldConf(pattern=r\"\\d{8}_\\d{6}\", datetime_format=\"%Y%m%d_%H%M%S\"),  # generation datetime\n        \"ext\": FieldConf(pattern=SafePatterns.EXTENSION),  # csv, xls, parquet, etc\n    },\n)\n</code></pre></p>"},{"location":"#how-to-reorganize-files-and-folders-in-a-datalake","title":"How to reorganize files and folders in a datalake","text":"<p>In this example we will reorganize a flatten file structure into a nested one. First define the two PathModels, the old one and the new one:</p> <pre><code>from andar import FieldConf, PathModel, SafePatterns\n\nold_flat_pm = PathModel(\n    template=\"{base_path}/{category}_{name}_{date}.{ext}\",\n    fields={\n        \"base_path\": FieldConf(pattern=SafePatterns.DIRPATH),\n        \"category\": FieldConf(pattern=SafePatterns.NAME),\n        \"name\": FieldConf(pattern=SafePatterns.FIELD),\n        \"date\": FieldConf(pattern=r\"\\d{8}\", datetime_format=\"%Y%m%d\"),\n        \"ext\": FieldConf(pattern=SafePatterns.EXTENSION),\n    },\n)\n\n# we can just update the template if the fields are de same\nnew_nested_pm = old_flat_pm.update(\n    template=\"{base_path}/{category}/{date}/{name}.{ext}\"\n)\n</code></pre> <p>Example of file creating in a temporary directory using a flatten structure with the old PathModel:</p> <pre><code>import pathlib\nimport tempfile\nimport datetime as dt\n\nbase_path = tempfile.mkdtemp()\nstart_date = dt.datetime(2025, 12, 1)\ndate_list = [start_date + dt.timedelta(days=d) for d in range(10)]\n\nfor date in date_list:\n    creation_datetime = dt.datetime.now()\n    file_path = old_flat_pm.get_path(\n        base_path=base_path,\n        category=\"sales\",\n        name=\"orders\",\n        date=date,\n        ext=\"csv\",\n    )\n    print(file_path)\n    pathlib.Path(file_path).touch()  # create an empty file\n</code></pre> <p>Example of nesting file paths using the parser of the old PathModel and the get_path of the new PathModel:</p> <pre><code># First list existing files in target base path\nsearch_folder = pathlib.Path(base_path)\npath_list = [str(i) for i in search_folder.rglob(\"*\") if i.is_file()]\n\nfor file_path in path_list:\n    parsed_fields = old_flat_pm.parse_path(file_path)\n    # As the fields are the same we can reuse them directly\n    new_file_path = new_nested_pm.get_path(**parsed_fields)\n    # create new parent directories\n    pathlib.Path(new_file_path).parent.mkdir(parents=True, exist_ok=True)\n    # move old file to new location using the new name\n    pathlib.Path(file_path).replace(new_file_path)\n</code></pre> <p>The same strategy could be adapted to flatten a nested path structure using PathModels.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>See the official documentation to learn more.</p>"},{"location":"reference/andar/","title":"andar","text":""},{"location":"reference/andar/#andar","title":"<code>andar</code>","text":""},{"location":"reference/andar/#andar.FieldConf","title":"<code>FieldConf</code>  <code>dataclass</code>","text":"<p>FieldConf allows to configure how a path field is validated, parsed and processed</p> <p>:param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using                 parse_path. By default, it used SafePatterns.FILENAME. :param date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a                     string or a datetime object that can be formated to an input string for a the given template.                     They are also used for validating the parsed field when using parse_path and for defining how                     to cast the string (to date or to datetime, depending on the argument that was used). :param datetime_format: See description of date_format parameter. :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)                     or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must                     be constrained, otherwise the PathModel class may have an unexpected behaviour.                     For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.</p> Source code in <code>andar/field_conf.py</code> <pre><code>@dataclass\nclass FieldConf:\n    \"\"\"\n    FieldConf allows to configure how a path field is validated, parsed and processed\n\n    :param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using\n                    parse_path. By default, it used SafePatterns.FILENAME.\n    :param date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a\n                        string or a datetime object that can be formated to an input string for a the given template.\n                        They are also used for validating the parsed field when using parse_path and for defining how\n                        to cast the string (to date or to datetime, depending on the argument that was used).\n    :param datetime_format: See description of date_format parameter.\n    :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)\n                        or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must\n                        be constrained, otherwise the PathModel class may have an unexpected behaviour.\n                        For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.\n    \"\"\"\n\n    pattern: str = SafePatterns.NAME\n    date_format: str | None = None\n    datetime_format: str | None = None\n    is_optional: bool | None = None\n    str_to_var: Callable | None = None\n    var_to_str: Callable | None = None\n\n    def __post_init__(self):\n        has_date_converter = self.date_format is not None\n        has_datetime_converter = self.datetime_format is not None\n        has_custom_converter = self.var_to_str is not None or self.str_to_var is not None\n        active_converters_num = sum([has_date_converter, has_datetime_converter, has_custom_converter])\n        if active_converters_num &gt; 1:\n            raise ValueError(f\"Maximum one field converter is allowed, but {active_converters_num} were found\")\n\n    def __repr__(self):\n        formatted_fields = []\n        for k, v in vars(self).items():\n            if v is None:\n                continue\n            v_str = f\"'{v}'\" if isinstance(v, str) else v.__qualname__\n            field_str = f\"{k}={v_str}\"\n            formatted_fields.append(field_str)\n        formatted_fields_str = \", \".join(formatted_fields)\n        repr = f\"FieldConf({formatted_fields_str})\"\n        return repr\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced\n        :return: An FieldConf object with the attributes replaced\n        \"\"\"\n        field_conf = replace(self, **kwargs)\n        return field_conf\n</code></pre>"},{"location":"reference/andar/#andar.FieldConf.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced :return: An FieldConf object with the attributes replaced</p> Source code in <code>andar/field_conf.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced\n    :return: An FieldConf object with the attributes replaced\n    \"\"\"\n    field_conf = replace(self, **kwargs)\n    return field_conf\n</code></pre>"},{"location":"reference/andar/#andar.PathModel","title":"<code>PathModel</code>","text":"<p>PathModel allows to define, build and parse templated file paths</p> <p>It defines a path via a template and its fields. Once instantiated, it allows to build new paths and to parse path strings to recover individual fields.</p> Source code in <code>andar/path_model.py</code> <pre><code>class PathModel:\n    \"\"\"\n    PathModel allows to define, build and parse templated file paths\n\n    It defines a path via a template and its fields. Once instantiated, it allows to build new paths\n    and to parse path strings to recover individual fields.\n\n    \"\"\"\n\n    template: str\n    fields: dict[str, FieldConf]\n    default_field: FieldConf\n    parent_template: str\n    description: str\n    _dir_sep: str = \"/\"\n\n    def __init__(\n        self,\n        template: str,\n        fields: dict[str, FieldConf] | None = None,\n        default_field: FieldConf | None = None,\n        parent_template: str | None = None,\n        description: str | None = None,\n    ):\n        self.template = template\n        self._fields = fields\n        self._parent_template = parent_template\n        self._default_field = default_field\n        self._description = description\n\n        if parent_template is None:\n            parent_template = os.path.dirname(self.template)\n        check_parent_path_template(template, parent_template)\n        self.parent_template = parent_template\n\n        if default_field is None:\n            default_field = FieldConf()\n        self.default_field = default_field\n\n        new_fields = {}\n        template_field_names = get_template_fields_names(template)\n        for field_name in template_field_names:\n            new_fields[field_name] = default_field\n\n        if fields is not None:\n            new_fields.update(fields)\n        self.fields = new_fields\n\n        new_field_names = list(new_fields.keys())\n        check_expected_fields(template_field_names, new_field_names)\n\n        if description is None:\n            description = \"\"\n        self.description = description\n\n    def __repr__(self):\n        ident = \"  \"\n        formatted_fields = \"\\n\".join([f\"{ident * 2}'{k}': {v},\" for k, v in self.fields.items()])\n        formatted_args = [f\"{ident}template='{self.template}',\"]\n        if self._fields is not None:\n            formatted_args.append(f\"{ident}fields={{\\n{formatted_fields}\\n  }},\")\n        if self._default_field is not None:\n            formatted_args.append(f\"{ident}default_field={self.default_field},\")\n        if self._parent_template is not None:\n            formatted_args.append(f\"{ident}parent_template='{self.parent_template}',\")\n        if self._description is not None:\n            formatted_args.append(f\"{ident}description='{self.description}',\")\n        formatted_args_str = \"\\n\".join(formatted_args)\n        repr = f\"PathModel(\\n{formatted_args_str}\\n)\"\n        return repr\n\n    def replace(self, copy_description: bool = False, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n        :return: A PathModel instance\n        \"\"\"\n        default_parent_template = None  # default value when a new template is given, if not it reuse a previous one\n        if \"template\" not in kwargs:\n            kwargs[\"template\"] = self.template\n            default_parent_template = self._parent_template\n        if \"parent_template\" not in kwargs:\n            kwargs[\"parent_template\"] = default_parent_template  # reset to None when a new template is set\n        if \"fields\" not in kwargs:\n            kwargs[\"fields\"] = self._fields\n        if \"default_field\" not in kwargs:\n            kwargs[\"default_field\"] = self._default_field\n        default_description = None\n        if copy_description:\n            default_description = self._description\n        if \"description\" not in kwargs:\n            kwargs[\"description\"] = default_description\n\n        return self.__class__(**kwargs)\n\n    def update(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object updating attributes with the given keyword arguments\n        :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                       Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                       be removed.\n        :return: A PathModel instance\n        \"\"\"\n        fields = self.fields.copy()\n        if \"fields\" in kwargs:\n            fields.update(kwargs[\"fields\"])\n            fields_names = list(fields.keys())\n            [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n            kwargs[\"fields\"] = fields\n        return self.replace(**kwargs)\n\n    def __call__(self, **kwargs) -&gt; Self:\n        if not kwargs:\n            return self\n        return self.replace(**kwargs)\n\n    def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n        \"\"\"\n        Parse a file path\n\n        :param file_path: String to be parsed.\n        :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n        :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n                 string (or converted object)\n        \"\"\"\n        ds = self._dir_sep\n        path_template = self.template\n        path_template = path_template.replace(r\".\", r\"\\.\")\n        pattern_dict = {}\n        for field_name, field_conf in self.fields.items():\n            field_pattern = field_conf.pattern\n            if field_conf.is_optional:\n                field_pattern = f\"{field_pattern}|\"\n                # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n                field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n                optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n                path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n            pattern_dict[field_name] = field_pattern\n        parsed_fields = parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n        processed_fields = process_parsed_fields_values(self.fields, parsed_fields)\n        return processed_fields\n\n    @classmethod\n    def _get_path(\n        cls,\n        template: str,\n        fields_conf: dict[str, FieldConf],\n        fields_values_dict: dict[str, Any],\n    ) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param template: A template that follows string.Formatter() syntax.\n        :param fields_conf: Dictionary of fields configurations, where keys are field names and values are FieldConf\n                            instances.\n        :param fields_values_dict: Input parameters dict that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        fields_values_dict = fields_values_dict.copy()\n        template_field_names = get_template_fields_names(template)\n        missing_field_names = [field for field in template_field_names if field not in fields_values_dict]\n\n        for field_name in missing_field_names:\n            is_optional = fields_conf[field_name].is_optional\n            if is_optional:\n                fields_values_dict[field_name] = None\n\n        given_field_names = list(fields_values_dict.keys())\n        check_expected_fields(template_field_names, given_field_names)\n        fields_values_dict = prepare_fields_values(fields_values_dict, fields_conf)\n        new_path = template.format(**fields_values_dict)\n        new_path = os.path.normpath(new_path)\n        return new_path\n\n    def get_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n\n    def get_parent_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate parent path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                       parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                       updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                       an error will be raised.\n        :return: String. Parent path.\n        \"\"\"\n\n        # remove all fields not present in parent template\n        parent_fields = self.fields.copy()\n        fields_names = get_template_fields_names(self.template)\n        parent_fields_names = get_template_fields_names(self.parent_template)\n\n        # Drop fields corresponding to filename\n        for field in fields_names:\n            if field not in parent_fields_names:\n                parent_fields.pop(field)\n\n        # Make dynamic the parent path creation, so the last fields can be omitted\n        # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n        new_parent_template = self.parent_template\n        dynamic_fields_names = []\n        missing_kwarg_name = None\n        for parent_field_name in parent_fields_names:\n            is_optional = parent_fields[parent_field_name].is_optional\n            if parent_field_name not in kwargs and not is_optional:\n                # keep known (left) part of parent_template and drop the rest\n                missing_kwarg_name = parent_field_name\n                new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n                break\n            dynamic_fields_names.append(parent_field_name)\n\n        # Drop fields corresponding to last arguments that were skipped\n        parent_fields_names = list(parent_fields.keys())\n        for field_name in parent_fields_names:\n            if field_name not in dynamic_fields_names:\n                parent_fields.pop(field_name)\n\n        # Check for unnecessary extra args\n        extra_kwargs = {}\n        for field_name in kwargs:\n            if field_name not in parent_fields:\n                extra_kwargs[field_name] = kwargs[field_name]\n        if missing_kwarg_name and extra_kwargs:\n            raise ValueError(\n                f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n                f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n            )\n\n        return self._get_path(\n            template=new_parent_template,\n            fields_conf=parent_fields,\n            fields_values_dict=kwargs,\n        )\n\n    def assert_path_bijection(self, test_path: str):\n        \"\"\"\n        Assert path bijection\n\n        It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n        :param test_path: Path string to be tested\n        \"\"\"\n        parsed_fields = self.parse_path(test_path, raise_error=True)\n        result_test_path = self.get_path(**parsed_fields)\n        assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n\n    def assert_fields_bijection(self, test_fields: dict[str, Any]):\n        \"\"\"\n        Assert fields bijection\n\n        It tries to recover the same initial input after processing once with get_path and parse_file_path\n        This method is the preferred way of checking if the PathModel was well-defined.\n\n        :param test_fields: Dictionary of fields to be tested\n        \"\"\"\n        test_path = self.get_path(**test_fields)\n        result_parsed_fields = self.parse_path(test_path, raise_error=True)\n        assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.assert_fields_bijection","title":"<code>assert_fields_bijection(test_fields)</code>","text":"<p>Assert fields bijection</p> <p>It tries to recover the same initial input after processing once with get_path and parse_file_path This method is the preferred way of checking if the PathModel was well-defined.</p> <p>:param test_fields: Dictionary of fields to be tested</p> Source code in <code>andar/path_model.py</code> <pre><code>def assert_fields_bijection(self, test_fields: dict[str, Any]):\n    \"\"\"\n    Assert fields bijection\n\n    It tries to recover the same initial input after processing once with get_path and parse_file_path\n    This method is the preferred way of checking if the PathModel was well-defined.\n\n    :param test_fields: Dictionary of fields to be tested\n    \"\"\"\n    test_path = self.get_path(**test_fields)\n    result_parsed_fields = self.parse_path(test_path, raise_error=True)\n    assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.assert_path_bijection","title":"<code>assert_path_bijection(test_path)</code>","text":"<p>Assert path bijection</p> <p>It tries to recover the same initial input after processing once with parse_file_path and get_path</p> <p>:param test_path: Path string to be tested</p> Source code in <code>andar/path_model.py</code> <pre><code>def assert_path_bijection(self, test_path: str):\n    \"\"\"\n    Assert path bijection\n\n    It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n    :param test_path: Path string to be tested\n    \"\"\"\n    parsed_fields = self.parse_path(test_path, raise_error=True)\n    result_test_path = self.get_path(**parsed_fields)\n    assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.get_parent_path","title":"<code>get_parent_path(**kwargs)</code>","text":"<p>Generate parent path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. They are used in the order of                parent_template, if the last argument(s) are omitted, the parent_template will be dynamically                updated to a shorter version. If an argument in the middle is omitted, and it is not optional,                an error will be raised. :return: String. Parent path.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_parent_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate parent path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                   parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                   updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                   an error will be raised.\n    :return: String. Parent path.\n    \"\"\"\n\n    # remove all fields not present in parent template\n    parent_fields = self.fields.copy()\n    fields_names = get_template_fields_names(self.template)\n    parent_fields_names = get_template_fields_names(self.parent_template)\n\n    # Drop fields corresponding to filename\n    for field in fields_names:\n        if field not in parent_fields_names:\n            parent_fields.pop(field)\n\n    # Make dynamic the parent path creation, so the last fields can be omitted\n    # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n    new_parent_template = self.parent_template\n    dynamic_fields_names = []\n    missing_kwarg_name = None\n    for parent_field_name in parent_fields_names:\n        is_optional = parent_fields[parent_field_name].is_optional\n        if parent_field_name not in kwargs and not is_optional:\n            # keep known (left) part of parent_template and drop the rest\n            missing_kwarg_name = parent_field_name\n            new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n            break\n        dynamic_fields_names.append(parent_field_name)\n\n    # Drop fields corresponding to last arguments that were skipped\n    parent_fields_names = list(parent_fields.keys())\n    for field_name in parent_fields_names:\n        if field_name not in dynamic_fields_names:\n            parent_fields.pop(field_name)\n\n    # Check for unnecessary extra args\n    extra_kwargs = {}\n    for field_name in kwargs:\n        if field_name not in parent_fields:\n            extra_kwargs[field_name] = kwargs[field_name]\n    if missing_kwarg_name and extra_kwargs:\n        raise ValueError(\n            f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n            f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n        )\n\n    return self._get_path(\n        template=new_parent_template,\n        fields_conf=parent_fields,\n        fields_values_dict=kwargs,\n    )\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.get_path","title":"<code>get_path(**kwargs)</code>","text":"<p>Generate path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. :return: String. Path.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values.\n    :return: String. Path.\n    \"\"\"\n    return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.parse_path","title":"<code>parse_path(file_path, raise_error=False)</code>","text":"<p>Parse a file path</p> <p>:param file_path: String to be parsed. :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None. :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed          string (or converted object)</p> Source code in <code>andar/path_model.py</code> <pre><code>def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n    \"\"\"\n    Parse a file path\n\n    :param file_path: String to be parsed.\n    :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n    :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n             string (or converted object)\n    \"\"\"\n    ds = self._dir_sep\n    path_template = self.template\n    path_template = path_template.replace(r\".\", r\"\\.\")\n    pattern_dict = {}\n    for field_name, field_conf in self.fields.items():\n        field_pattern = field_conf.pattern\n        if field_conf.is_optional:\n            field_pattern = f\"{field_pattern}|\"\n            # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n            field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n            optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n            path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n        pattern_dict[field_name] = field_pattern\n    parsed_fields = parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n    processed_fields = process_parsed_fields_values(self.fields, parsed_fields)\n    return processed_fields\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.replace","title":"<code>replace(copy_description=False, **kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation :return: A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def replace(self, copy_description: bool = False, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n    :return: A PathModel instance\n    \"\"\"\n    default_parent_template = None  # default value when a new template is given, if not it reuse a previous one\n    if \"template\" not in kwargs:\n        kwargs[\"template\"] = self.template\n        default_parent_template = self._parent_template\n    if \"parent_template\" not in kwargs:\n        kwargs[\"parent_template\"] = default_parent_template  # reset to None when a new template is set\n    if \"fields\" not in kwargs:\n        kwargs[\"fields\"] = self._fields\n    if \"default_field\" not in kwargs:\n        kwargs[\"default_field\"] = self._default_field\n    default_description = None\n    if copy_description:\n        default_description = self._description\n    if \"description\" not in kwargs:\n        kwargs[\"description\"] = default_description\n\n    return self.__class__(**kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.update","title":"<code>update(**kwargs)</code>","text":"<p>Creates a copy of the current object updating attributes with the given keyword arguments :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.                Fields set to None, will be reset to default, if it is no longer present on the template, it will                be removed. :return: A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def update(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object updating attributes with the given keyword arguments\n    :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                   Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                   be removed.\n    :return: A PathModel instance\n    \"\"\"\n    fields = self.fields.copy()\n    if \"fields\" in kwargs:\n        fields.update(kwargs[\"fields\"])\n        fields_names = list(fields.keys())\n        [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n        kwargs[\"fields\"] = fields\n    return self.replace(**kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.SafePatterns","title":"<code>SafePatterns</code>","text":"<p>Non-greedy patterns</p> Source code in <code>andar/field_conf.py</code> <pre><code>class SafePatterns:\n    \"\"\"\n    Non-greedy patterns\n    \"\"\"\n\n    NAME = r\"[-_.a-zA-Z0-9]+?\"  # include name separators: -_.\n    DIRPATH = r\"[-_.a-zA-Z0-9/]+?\"  # include name separators: -_. and directory separator: /\n    FIELD = r\"[a-zA-Z0-9]+?\"  # without separator characters\n    EXTENSION = r\"[.a-zA-Z0-9]+?\"  # include dots for sub extensions as 'tar.gz'\n</code></pre>"},{"location":"reference/andar/check_utils/","title":"check_utils","text":""},{"location":"reference/andar/check_utils/#andar.check_utils","title":"<code>andar.check_utils</code>","text":""},{"location":"reference/andar/check_utils/#andar.check_utils.check_expected_fields","title":"<code>check_expected_fields(expected_field_names, new_field_names)</code>","text":"<p>Check if fields in the expected_field_names are coherent with new_field_names</p> <p>:param expected_field_names: The expected list of field names. :param new_field_names: The new list of field names to be validated.</p> Source code in <code>andar/check_utils.py</code> <pre><code>def check_expected_fields(expected_field_names: list[str], new_field_names: list[str]) -&gt; None:\n    \"\"\"\n    Check if fields in the expected_field_names are coherent with new_field_names\n\n    :param expected_field_names: The expected list of field names.\n    :param new_field_names: The new list of field names to be validated.\n    \"\"\"\n    invalid_fields = [f for f in new_field_names if f not in expected_field_names]\n    if invalid_fields:\n        raise ValueError(\n            f\"Invalid fields: {invalid_fields} they do not exist in expected field list: '{expected_field_names}'\"\n        )\n\n    missing_fields = [f for f in expected_field_names if f not in new_field_names]\n    if missing_fields:\n        raise ValueError(\n            f\"Missing fields: {missing_fields} they are required in expected field list: '{expected_field_names}'\"\n        )\n</code></pre>"},{"location":"reference/andar/check_utils/#andar.check_utils.check_parent_path_template","title":"<code>check_parent_path_template(path_template, parent_path_template)</code>","text":"<p>Check if parent_path_template is coherent with path_template</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.</p> Source code in <code>andar/check_utils.py</code> <pre><code>def check_parent_path_template(path_template: str, parent_path_template: str) -&gt; None:\n    \"\"\"\n    Check if parent_path_template is coherent with path_template\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.\n    \"\"\"\n    if parent_path_template not in path_template:\n        raise ValueError(\n            f\"path_template: '{path_template}' does not match with parent_path_template: \"\n            f\"'{parent_path_template}'. parent_path_template must be a substring of path_template\"\n        )\n</code></pre>"},{"location":"reference/andar/examples/","title":"examples","text":""},{"location":"reference/andar/examples/#andar.examples","title":"<code>andar.examples</code>","text":""},{"location":"reference/andar/examples/path_model_examples/","title":"path_model_examples","text":""},{"location":"reference/andar/examples/path_model_examples/#andar.examples.path_model_examples","title":"<code>andar.examples.path_model_examples</code>","text":""},{"location":"reference/andar/field_conf/","title":"field_conf","text":""},{"location":"reference/andar/field_conf/#andar.field_conf","title":"<code>andar.field_conf</code>","text":""},{"location":"reference/andar/field_conf/#andar.field_conf.FieldConf","title":"<code>FieldConf</code>  <code>dataclass</code>","text":"<p>FieldConf allows to configure how a path field is validated, parsed and processed</p> <p>:param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using                 parse_path. By default, it used SafePatterns.FILENAME. :param date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a                     string or a datetime object that can be formated to an input string for a the given template.                     They are also used for validating the parsed field when using parse_path and for defining how                     to cast the string (to date or to datetime, depending on the argument that was used). :param datetime_format: See description of date_format parameter. :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)                     or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must                     be constrained, otherwise the PathModel class may have an unexpected behaviour.                     For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.</p> Source code in <code>andar/field_conf.py</code> <pre><code>@dataclass\nclass FieldConf:\n    \"\"\"\n    FieldConf allows to configure how a path field is validated, parsed and processed\n\n    :param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using\n                    parse_path. By default, it used SafePatterns.FILENAME.\n    :param date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a\n                        string or a datetime object that can be formated to an input string for a the given template.\n                        They are also used for validating the parsed field when using parse_path and for defining how\n                        to cast the string (to date or to datetime, depending on the argument that was used).\n    :param datetime_format: See description of date_format parameter.\n    :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)\n                        or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must\n                        be constrained, otherwise the PathModel class may have an unexpected behaviour.\n                        For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.\n    \"\"\"\n\n    pattern: str = SafePatterns.NAME\n    date_format: str | None = None\n    datetime_format: str | None = None\n    is_optional: bool | None = None\n    str_to_var: Callable | None = None\n    var_to_str: Callable | None = None\n\n    def __post_init__(self):\n        has_date_converter = self.date_format is not None\n        has_datetime_converter = self.datetime_format is not None\n        has_custom_converter = self.var_to_str is not None or self.str_to_var is not None\n        active_converters_num = sum([has_date_converter, has_datetime_converter, has_custom_converter])\n        if active_converters_num &gt; 1:\n            raise ValueError(f\"Maximum one field converter is allowed, but {active_converters_num} were found\")\n\n    def __repr__(self):\n        formatted_fields = []\n        for k, v in vars(self).items():\n            if v is None:\n                continue\n            v_str = f\"'{v}'\" if isinstance(v, str) else v.__qualname__\n            field_str = f\"{k}={v_str}\"\n            formatted_fields.append(field_str)\n        formatted_fields_str = \", \".join(formatted_fields)\n        repr = f\"FieldConf({formatted_fields_str})\"\n        return repr\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced\n        :return: An FieldConf object with the attributes replaced\n        \"\"\"\n        field_conf = replace(self, **kwargs)\n        return field_conf\n</code></pre>"},{"location":"reference/andar/field_conf/#andar.field_conf.FieldConf.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced :return: An FieldConf object with the attributes replaced</p> Source code in <code>andar/field_conf.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced\n    :return: An FieldConf object with the attributes replaced\n    \"\"\"\n    field_conf = replace(self, **kwargs)\n    return field_conf\n</code></pre>"},{"location":"reference/andar/field_conf/#andar.field_conf.SafePatterns","title":"<code>SafePatterns</code>","text":"<p>Non-greedy patterns</p> Source code in <code>andar/field_conf.py</code> <pre><code>class SafePatterns:\n    \"\"\"\n    Non-greedy patterns\n    \"\"\"\n\n    NAME = r\"[-_.a-zA-Z0-9]+?\"  # include name separators: -_.\n    DIRPATH = r\"[-_.a-zA-Z0-9/]+?\"  # include name separators: -_. and directory separator: /\n    FIELD = r\"[a-zA-Z0-9]+?\"  # without separator characters\n    EXTENSION = r\"[.a-zA-Z0-9]+?\"  # include dots for sub extensions as 'tar.gz'\n</code></pre>"},{"location":"reference/andar/parser_utils/","title":"parser_utils","text":""},{"location":"reference/andar/parser_utils/#andar.parser_utils","title":"<code>andar.parser_utils</code>","text":"<p>Module containing utility functions</p>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.assign_groupname_pattern_dict","title":"<code>assign_groupname_pattern_dict(pattern_dict)</code>","text":"<p>Assign a group name to each regex pattern present in the given dictionary</p> <p>:param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not                         check if the pattern already have a group name assign. :return: A dictionary where the patterns have been assigned a group name.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def assign_groupname_pattern_dict(pattern_dict: dict[str:str]) -&gt; dict[str:str]:\n    \"\"\"\n    Assign a group name to each regex pattern present in the given dictionary\n\n    :param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not\n                            check if the pattern already have a group name assign.\n    :return: A dictionary where the patterns have been assigned a group name.\n    \"\"\"\n    named_pattern_dict = {}\n    for field, pattern in pattern_dict.items():\n        named_pattern_dict[field] = f\"(?P&lt;{field}&gt;{pattern})\"\n    return named_pattern_dict\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.get_template_fields_names","title":"<code>get_template_fields_names(path_template)</code>","text":"<p>Get fields names from path template string</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :return: List. Template fields names.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def get_template_fields_names(path_template: str) -&gt; list[str]:\n    \"\"\"\n    Get fields names from path template string\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :return: List. Template fields names.\n    \"\"\"\n    parsed_field_tuples = list(string.Formatter().parse(path_template))\n    template_fields_names = [name for (text, name, spec, conv) in parsed_field_tuples if name is not None]\n    return template_fields_names\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.parse_fields","title":"<code>parse_fields(_string, template, pattern_dict, raise_error=False)</code>","text":"<p>Parse a string using a template and a patterns dictionary</p> <p>Example: filename_template = \"{prefix}_{name}.{extension}\" pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"} filename = \"0001_example.json\" parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict) invalid_filename = \"invalid_example.json\" parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)</p> <p>:param _string: String to be parsed. :param template: A template that follows string.Formatter() syntax. :param pattern_dict: A dictionary where each key represent a field of the template and each value is the                         corresponding regex pattern :param raise_error: Raise an exception if the path is not valid. If False, it returns None. :return: A dictionary of parsed fields.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def parse_fields(\n    _string: str,\n    template: str,\n    pattern_dict: dict[str:str],\n    raise_error: bool = False,\n) -&gt; dict[str:str]:\n    \"\"\"\n    Parse a string using a template and a patterns dictionary\n\n    Example:\n    filename_template = \"{prefix}_{name}.{extension}\"\n    pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"}\n    filename = \"0001_example.json\"\n    parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict)\n    invalid_filename = \"invalid_example.json\"\n    parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)\n\n    :param _string: String to be parsed.\n    :param template: A template that follows string.Formatter() syntax.\n    :param pattern_dict: A dictionary where each key represent a field of the template and each value is the\n                            corresponding regex pattern\n    :param raise_error: Raise an exception if the path is not valid. If False, it returns None.\n    :return: A dictionary of parsed fields.\n    \"\"\"\n    template_field_names = get_template_fields_names(template)\n    pattern_field_names = list(pattern_dict.keys())\n    check_expected_fields(template_field_names, pattern_field_names)\n\n    # Deduplicate repeated fields of pattern_dict:\n    # for example the template \"/{base_path}/{asset_name}/{asset_name}_{suffix}\"\n    # will become \"/{base_path}/{asset_name__0}/{asset_name__1}_{suffix}\"\n    # and the dict {\"base_path\": r\"\\w+\", \"asset_name\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    # will become {\"base_path\": r\"\\w+\", \"asset_name__0\": r\"\\w+\", \"asset_name__1\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    unique_fields = list(set(template_field_names))\n    deduplicated_fields_dict = {}\n    new_pattern_dict = {}\n    new_template = template\n    for field_name in unique_fields:\n        field_count = len([f for f in template_field_names if f == field_name])\n        if field_count == 1:\n            new_pattern_dict[field_name] = pattern_dict[field_name]\n            continue\n        deduplicated_list = []\n        for idx in range(field_count):\n            new_field_name = field_name + f\"__{idx}\"\n            deduplicated_list.append(new_field_name)\n            new_pattern_dict[new_field_name] = pattern_dict[field_name]\n            new_template = new_template.replace(\"{\" + field_name + \"}\", \"{\" + new_field_name + \"}\", 1)\n        deduplicated_fields_dict[field_name] = deduplicated_list\n\n    has_duplicates = pattern_dict != new_pattern_dict\n    if has_duplicates:\n        pattern_dict = new_pattern_dict\n        template = new_template\n\n    # Build full pattern string\n    named_pattern_dict = assign_groupname_pattern_dict(pattern_dict)\n    path_pattern = template.format(**named_pattern_dict)\n    path_pattern = f\"^{path_pattern}$\"  # match the full string\n    match = re.match(path_pattern, _string)\n    if not match:\n        if raise_error:\n            raise ValueError(f\"Invalid string '{_string}', expected pattern: '{path_pattern}'\")\n        return None\n    parsed_fields_dict = match.groupdict()\n\n    # Fusion deduplicated fields:\n    # it will raise an error if the deduplicate fields have multiples values\n    # for example this parsed dict will raise an error because asset_name__0 and asset_name__1 should be equal:\n    # {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"other_asset\", \"suffix\": \"001\"}\n    # if the deduplicated fields are coherent they will be fusion and renamed to its original name:\n    # for example {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"my_asset\", \"suffix\": \"001\"}\n    # to {\"base_path\": \"folder\", \"asset_name\": \"my_asset\", \"suffix\": \"001\"}\n    for original_field_name, deduplicated_list in deduplicated_fields_dict.items():\n        parsed_field_values = [parsed_fields_dict.pop(f) for f in deduplicated_list]\n        unique_parsed_field_values = list(set(parsed_field_values))\n        are_duplicated_unique = len(unique_parsed_field_values) == 1\n        if not are_duplicated_unique:\n            raise ValueError(\n                f\"More than one value was found for repeated field '{original_field_name}': {parsed_field_values}\"\n            )\n        parsed_fields_dict[original_field_name] = unique_parsed_field_values[0]\n\n    return parsed_fields_dict\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.prepare_fields_values","title":"<code>prepare_fields_values(fields_values_dict, fields_conf)</code>","text":"<p>Prepare fields values for this path :param fields_values_dict: Dictionary of fields values :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf) :return: A dictionary of fields where the values were converted to strings.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def prepare_fields_values(fields_values_dict: dict[str:Any], fields_conf: dict[str, FieldConf]) -&gt; dict[str:str]:\n    \"\"\"\n    Prepare fields values for this path\n    :param fields_values_dict: Dictionary of fields values\n    :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf)\n    :return: A dictionary of fields where the values were converted to strings.\n    \"\"\"\n    new_fields_values_dict = {}\n    for field_name, field_value in fields_values_dict.items():\n        if field_name not in fields_conf:\n            print(f\"skipping field '{field_name}'\")\n            continue\n        field_conf = fields_conf[field_name]\n\n        if field_value is None and field_conf.is_optional:\n            new_fields_values_dict[field_name] = \"\"\n            continue\n\n        if field_conf.date_format is not None:\n            new_field_value = field_value.strftime(field_conf.date_format)\n        elif field_conf.datetime_format is not None:\n            new_field_value = field_value.strftime(field_conf.datetime_format)\n        elif field_conf.var_to_str is not None:\n            new_field_value = field_conf.var_to_str(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        result = re.match(field_pattern, new_field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{new_field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n        new_fields_values_dict[field_name] = new_field_value\n    return new_fields_values_dict\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.process_parsed_fields_values","title":"<code>process_parsed_fields_values(fields_conf, parsed_fields)</code>","text":"<p>Process fields values dictionary obtained from parsing a file path</p> <p>:param parsed_fields: A dictionary of parsed fields values in string format. :return: A processed dictionary of fields with converted values depending on each FieldConf definition.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def process_parsed_fields_values(fields_conf: dict[str, FieldConf], parsed_fields: dict[str:str]) -&gt; dict[str:Any]:\n    \"\"\"\n    Process fields values dictionary obtained from parsing a file path\n\n    :param parsed_fields: A dictionary of parsed fields values in string format.\n    :return: A processed dictionary of fields with converted values depending on each FieldConf definition.\n    \"\"\"\n    new_parsed_fields = parsed_fields.copy()\n\n    for field_name, field_value in new_parsed_fields.items():\n        if field_name not in fields_conf:\n            raise ValueError(f\"Unknown field '{field_name}'. Valid fields are: {fields_conf.keys()}\")\n        field_conf = fields_conf[field_name]\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        if field_conf.is_optional:\n            field_pattern = f\"^{field_conf.pattern}|$\"\n        result = re.match(field_pattern, field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n\n        if field_conf.date_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.date_format).date()\n        elif field_conf.datetime_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.datetime_format)\n        elif field_conf.str_to_var is not None:\n            new_field_value = field_conf.str_to_var(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        if new_field_value == \"\" and field_conf.is_optional:\n            new_field_value = None\n\n        new_parsed_fields[field_name] = new_field_value\n    return new_parsed_fields\n</code></pre>"},{"location":"reference/andar/path_model/","title":"path_model","text":""},{"location":"reference/andar/path_model/#andar.path_model","title":"<code>andar.path_model</code>","text":""},{"location":"reference/andar/path_model/#andar.path_model.PathModel","title":"<code>PathModel</code>","text":"<p>PathModel allows to define, build and parse templated file paths</p> <p>It defines a path via a template and its fields. Once instantiated, it allows to build new paths and to parse path strings to recover individual fields.</p> Source code in <code>andar/path_model.py</code> <pre><code>class PathModel:\n    \"\"\"\n    PathModel allows to define, build and parse templated file paths\n\n    It defines a path via a template and its fields. Once instantiated, it allows to build new paths\n    and to parse path strings to recover individual fields.\n\n    \"\"\"\n\n    template: str\n    fields: dict[str, FieldConf]\n    default_field: FieldConf\n    parent_template: str\n    description: str\n    _dir_sep: str = \"/\"\n\n    def __init__(\n        self,\n        template: str,\n        fields: dict[str, FieldConf] | None = None,\n        default_field: FieldConf | None = None,\n        parent_template: str | None = None,\n        description: str | None = None,\n    ):\n        self.template = template\n        self._fields = fields\n        self._parent_template = parent_template\n        self._default_field = default_field\n        self._description = description\n\n        if parent_template is None:\n            parent_template = os.path.dirname(self.template)\n        check_parent_path_template(template, parent_template)\n        self.parent_template = parent_template\n\n        if default_field is None:\n            default_field = FieldConf()\n        self.default_field = default_field\n\n        new_fields = {}\n        template_field_names = get_template_fields_names(template)\n        for field_name in template_field_names:\n            new_fields[field_name] = default_field\n\n        if fields is not None:\n            new_fields.update(fields)\n        self.fields = new_fields\n\n        new_field_names = list(new_fields.keys())\n        check_expected_fields(template_field_names, new_field_names)\n\n        if description is None:\n            description = \"\"\n        self.description = description\n\n    def __repr__(self):\n        ident = \"  \"\n        formatted_fields = \"\\n\".join([f\"{ident * 2}'{k}': {v},\" for k, v in self.fields.items()])\n        formatted_args = [f\"{ident}template='{self.template}',\"]\n        if self._fields is not None:\n            formatted_args.append(f\"{ident}fields={{\\n{formatted_fields}\\n  }},\")\n        if self._default_field is not None:\n            formatted_args.append(f\"{ident}default_field={self.default_field},\")\n        if self._parent_template is not None:\n            formatted_args.append(f\"{ident}parent_template='{self.parent_template}',\")\n        if self._description is not None:\n            formatted_args.append(f\"{ident}description='{self.description}',\")\n        formatted_args_str = \"\\n\".join(formatted_args)\n        repr = f\"PathModel(\\n{formatted_args_str}\\n)\"\n        return repr\n\n    def replace(self, copy_description: bool = False, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n        :return: A PathModel instance\n        \"\"\"\n        default_parent_template = None  # default value when a new template is given, if not it reuse a previous one\n        if \"template\" not in kwargs:\n            kwargs[\"template\"] = self.template\n            default_parent_template = self._parent_template\n        if \"parent_template\" not in kwargs:\n            kwargs[\"parent_template\"] = default_parent_template  # reset to None when a new template is set\n        if \"fields\" not in kwargs:\n            kwargs[\"fields\"] = self._fields\n        if \"default_field\" not in kwargs:\n            kwargs[\"default_field\"] = self._default_field\n        default_description = None\n        if copy_description:\n            default_description = self._description\n        if \"description\" not in kwargs:\n            kwargs[\"description\"] = default_description\n\n        return self.__class__(**kwargs)\n\n    def update(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object updating attributes with the given keyword arguments\n        :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                       Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                       be removed.\n        :return: A PathModel instance\n        \"\"\"\n        fields = self.fields.copy()\n        if \"fields\" in kwargs:\n            fields.update(kwargs[\"fields\"])\n            fields_names = list(fields.keys())\n            [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n            kwargs[\"fields\"] = fields\n        return self.replace(**kwargs)\n\n    def __call__(self, **kwargs) -&gt; Self:\n        if not kwargs:\n            return self\n        return self.replace(**kwargs)\n\n    def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n        \"\"\"\n        Parse a file path\n\n        :param file_path: String to be parsed.\n        :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n        :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n                 string (or converted object)\n        \"\"\"\n        ds = self._dir_sep\n        path_template = self.template\n        path_template = path_template.replace(r\".\", r\"\\.\")\n        pattern_dict = {}\n        for field_name, field_conf in self.fields.items():\n            field_pattern = field_conf.pattern\n            if field_conf.is_optional:\n                field_pattern = f\"{field_pattern}|\"\n                # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n                field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n                optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n                path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n            pattern_dict[field_name] = field_pattern\n        parsed_fields = parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n        processed_fields = process_parsed_fields_values(self.fields, parsed_fields)\n        return processed_fields\n\n    @classmethod\n    def _get_path(\n        cls,\n        template: str,\n        fields_conf: dict[str, FieldConf],\n        fields_values_dict: dict[str, Any],\n    ) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param template: A template that follows string.Formatter() syntax.\n        :param fields_conf: Dictionary of fields configurations, where keys are field names and values are FieldConf\n                            instances.\n        :param fields_values_dict: Input parameters dict that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        fields_values_dict = fields_values_dict.copy()\n        template_field_names = get_template_fields_names(template)\n        missing_field_names = [field for field in template_field_names if field not in fields_values_dict]\n\n        for field_name in missing_field_names:\n            is_optional = fields_conf[field_name].is_optional\n            if is_optional:\n                fields_values_dict[field_name] = None\n\n        given_field_names = list(fields_values_dict.keys())\n        check_expected_fields(template_field_names, given_field_names)\n        fields_values_dict = prepare_fields_values(fields_values_dict, fields_conf)\n        new_path = template.format(**fields_values_dict)\n        new_path = os.path.normpath(new_path)\n        return new_path\n\n    def get_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n\n    def get_parent_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate parent path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                       parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                       updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                       an error will be raised.\n        :return: String. Parent path.\n        \"\"\"\n\n        # remove all fields not present in parent template\n        parent_fields = self.fields.copy()\n        fields_names = get_template_fields_names(self.template)\n        parent_fields_names = get_template_fields_names(self.parent_template)\n\n        # Drop fields corresponding to filename\n        for field in fields_names:\n            if field not in parent_fields_names:\n                parent_fields.pop(field)\n\n        # Make dynamic the parent path creation, so the last fields can be omitted\n        # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n        new_parent_template = self.parent_template\n        dynamic_fields_names = []\n        missing_kwarg_name = None\n        for parent_field_name in parent_fields_names:\n            is_optional = parent_fields[parent_field_name].is_optional\n            if parent_field_name not in kwargs and not is_optional:\n                # keep known (left) part of parent_template and drop the rest\n                missing_kwarg_name = parent_field_name\n                new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n                break\n            dynamic_fields_names.append(parent_field_name)\n\n        # Drop fields corresponding to last arguments that were skipped\n        parent_fields_names = list(parent_fields.keys())\n        for field_name in parent_fields_names:\n            if field_name not in dynamic_fields_names:\n                parent_fields.pop(field_name)\n\n        # Check for unnecessary extra args\n        extra_kwargs = {}\n        for field_name in kwargs:\n            if field_name not in parent_fields:\n                extra_kwargs[field_name] = kwargs[field_name]\n        if missing_kwarg_name and extra_kwargs:\n            raise ValueError(\n                f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n                f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n            )\n\n        return self._get_path(\n            template=new_parent_template,\n            fields_conf=parent_fields,\n            fields_values_dict=kwargs,\n        )\n\n    def assert_path_bijection(self, test_path: str):\n        \"\"\"\n        Assert path bijection\n\n        It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n        :param test_path: Path string to be tested\n        \"\"\"\n        parsed_fields = self.parse_path(test_path, raise_error=True)\n        result_test_path = self.get_path(**parsed_fields)\n        assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n\n    def assert_fields_bijection(self, test_fields: dict[str, Any]):\n        \"\"\"\n        Assert fields bijection\n\n        It tries to recover the same initial input after processing once with get_path and parse_file_path\n        This method is the preferred way of checking if the PathModel was well-defined.\n\n        :param test_fields: Dictionary of fields to be tested\n        \"\"\"\n        test_path = self.get_path(**test_fields)\n        result_parsed_fields = self.parse_path(test_path, raise_error=True)\n        assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.assert_fields_bijection","title":"<code>assert_fields_bijection(test_fields)</code>","text":"<p>Assert fields bijection</p> <p>It tries to recover the same initial input after processing once with get_path and parse_file_path This method is the preferred way of checking if the PathModel was well-defined.</p> <p>:param test_fields: Dictionary of fields to be tested</p> Source code in <code>andar/path_model.py</code> <pre><code>def assert_fields_bijection(self, test_fields: dict[str, Any]):\n    \"\"\"\n    Assert fields bijection\n\n    It tries to recover the same initial input after processing once with get_path and parse_file_path\n    This method is the preferred way of checking if the PathModel was well-defined.\n\n    :param test_fields: Dictionary of fields to be tested\n    \"\"\"\n    test_path = self.get_path(**test_fields)\n    result_parsed_fields = self.parse_path(test_path, raise_error=True)\n    assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.assert_path_bijection","title":"<code>assert_path_bijection(test_path)</code>","text":"<p>Assert path bijection</p> <p>It tries to recover the same initial input after processing once with parse_file_path and get_path</p> <p>:param test_path: Path string to be tested</p> Source code in <code>andar/path_model.py</code> <pre><code>def assert_path_bijection(self, test_path: str):\n    \"\"\"\n    Assert path bijection\n\n    It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n    :param test_path: Path string to be tested\n    \"\"\"\n    parsed_fields = self.parse_path(test_path, raise_error=True)\n    result_test_path = self.get_path(**parsed_fields)\n    assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.get_parent_path","title":"<code>get_parent_path(**kwargs)</code>","text":"<p>Generate parent path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. They are used in the order of                parent_template, if the last argument(s) are omitted, the parent_template will be dynamically                updated to a shorter version. If an argument in the middle is omitted, and it is not optional,                an error will be raised. :return: String. Parent path.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_parent_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate parent path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                   parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                   updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                   an error will be raised.\n    :return: String. Parent path.\n    \"\"\"\n\n    # remove all fields not present in parent template\n    parent_fields = self.fields.copy()\n    fields_names = get_template_fields_names(self.template)\n    parent_fields_names = get_template_fields_names(self.parent_template)\n\n    # Drop fields corresponding to filename\n    for field in fields_names:\n        if field not in parent_fields_names:\n            parent_fields.pop(field)\n\n    # Make dynamic the parent path creation, so the last fields can be omitted\n    # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n    new_parent_template = self.parent_template\n    dynamic_fields_names = []\n    missing_kwarg_name = None\n    for parent_field_name in parent_fields_names:\n        is_optional = parent_fields[parent_field_name].is_optional\n        if parent_field_name not in kwargs and not is_optional:\n            # keep known (left) part of parent_template and drop the rest\n            missing_kwarg_name = parent_field_name\n            new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n            break\n        dynamic_fields_names.append(parent_field_name)\n\n    # Drop fields corresponding to last arguments that were skipped\n    parent_fields_names = list(parent_fields.keys())\n    for field_name in parent_fields_names:\n        if field_name not in dynamic_fields_names:\n            parent_fields.pop(field_name)\n\n    # Check for unnecessary extra args\n    extra_kwargs = {}\n    for field_name in kwargs:\n        if field_name not in parent_fields:\n            extra_kwargs[field_name] = kwargs[field_name]\n    if missing_kwarg_name and extra_kwargs:\n        raise ValueError(\n            f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n            f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n        )\n\n    return self._get_path(\n        template=new_parent_template,\n        fields_conf=parent_fields,\n        fields_values_dict=kwargs,\n    )\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.get_path","title":"<code>get_path(**kwargs)</code>","text":"<p>Generate path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. :return: String. Path.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values.\n    :return: String. Path.\n    \"\"\"\n    return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.parse_path","title":"<code>parse_path(file_path, raise_error=False)</code>","text":"<p>Parse a file path</p> <p>:param file_path: String to be parsed. :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None. :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed          string (or converted object)</p> Source code in <code>andar/path_model.py</code> <pre><code>def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n    \"\"\"\n    Parse a file path\n\n    :param file_path: String to be parsed.\n    :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n    :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n             string (or converted object)\n    \"\"\"\n    ds = self._dir_sep\n    path_template = self.template\n    path_template = path_template.replace(r\".\", r\"\\.\")\n    pattern_dict = {}\n    for field_name, field_conf in self.fields.items():\n        field_pattern = field_conf.pattern\n        if field_conf.is_optional:\n            field_pattern = f\"{field_pattern}|\"\n            # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n            field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n            optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n            path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n        pattern_dict[field_name] = field_pattern\n    parsed_fields = parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n    processed_fields = process_parsed_fields_values(self.fields, parsed_fields)\n    return processed_fields\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.replace","title":"<code>replace(copy_description=False, **kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation :return: A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def replace(self, copy_description: bool = False, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n    :return: A PathModel instance\n    \"\"\"\n    default_parent_template = None  # default value when a new template is given, if not it reuse a previous one\n    if \"template\" not in kwargs:\n        kwargs[\"template\"] = self.template\n        default_parent_template = self._parent_template\n    if \"parent_template\" not in kwargs:\n        kwargs[\"parent_template\"] = default_parent_template  # reset to None when a new template is set\n    if \"fields\" not in kwargs:\n        kwargs[\"fields\"] = self._fields\n    if \"default_field\" not in kwargs:\n        kwargs[\"default_field\"] = self._default_field\n    default_description = None\n    if copy_description:\n        default_description = self._description\n    if \"description\" not in kwargs:\n        kwargs[\"description\"] = default_description\n\n    return self.__class__(**kwargs)\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.update","title":"<code>update(**kwargs)</code>","text":"<p>Creates a copy of the current object updating attributes with the given keyword arguments :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.                Fields set to None, will be reset to default, if it is no longer present on the template, it will                be removed. :return: A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def update(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object updating attributes with the given keyword arguments\n    :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                   Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                   be removed.\n    :return: A PathModel instance\n    \"\"\"\n    fields = self.fields.copy()\n    if \"fields\" in kwargs:\n        fields.update(kwargs[\"fields\"])\n        fields_names = list(fields.keys())\n        [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n        kwargs[\"fields\"] = fields\n    return self.replace(**kwargs)\n</code></pre>"}]}