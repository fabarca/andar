{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Andar Docs","text":"<p>Andar package implements a PathModel class that allows to define, build and parse templated file paths.</p>"},{"location":"#project-overview","title":"Project Overview","text":""},{"location":"#example-usage","title":"Example usage:","text":"<pre><code>from andar import PathModel\n\n# Simple definition, using automatic definition of fields\nsimple_path_model = PathModel(template=\"/{base_folder}/{subfolder}/{base_name}__{suffix}.{extension}\")\n\n# Generate a path:\nresult_path = simple_path_model.get_path(\n    base_folder=\"parent_folder\",\n    subfolder=\"other_folder\",\n    base_name=\"mydata\",\n    suffix=\"2000-01-01\",\n    extension=\"csv\",\n)\nprint(result_path)\n# Result:\n# \"/parent_folder/other_folder/mydata__2000-01-01.csv\"\n\n# Parse a path:\nfile_path = \"/data/reports/summary__2025-12-31.csv\"\nparsed_fields = simple_path_model.parse_path(file_path)\nprint(parsed_fields)\n\n# Result:\n# {\n#     'base_folder': 'data', \n#     'subfolder': 'reports', \n#     'base_name': 'summary', \n#     'suffix': '2025-12-31', \n#     'extension': 'csv',\n# }\n\n</code></pre>"},{"location":"reference/andar/","title":"andar","text":""},{"location":"reference/andar/#andar","title":"<code>andar</code>","text":""},{"location":"reference/andar/#andar.FieldConf","title":"<code>FieldConf</code>  <code>dataclass</code>","text":"<p>FieldConf allows to configure how a path field is validated, parsed and processed</p> <p>:param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using                 parse_path. By default, it used SafePatterns.FILENAME. :param date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a                     string or a datetime object that can be formated to an input string for a the given template.                     They are also used for validating the parsed field when using parse_path and for defining how                     to cast the string (to date or to datetime, depending on the argument that was used). :param datetime_format: See description of date_format parameter. :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)                     or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must                     be constrained, otherwise the PathModel class may have an unexpected behaviour.                     For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.</p> Source code in <code>andar/field_conf.py</code> <pre><code>@dataclass\nclass FieldConf:\n    \"\"\"\n    FieldConf allows to configure how a path field is validated, parsed and processed\n\n    :param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using\n                    parse_path. By default, it used SafePatterns.FILENAME.\n    :param date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a\n                        string or a datetime object that can be formated to an input string for a the given template.\n                        They are also used for validating the parsed field when using parse_path and for defining how\n                        to cast the string (to date or to datetime, depending on the argument that was used).\n    :param datetime_format: See description of date_format parameter.\n    :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)\n                        or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must\n                        be constrained, otherwise the PathModel class may have an unexpected behaviour.\n                        For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.\n    \"\"\"\n\n    pattern: str = SafePatterns.FILENAME\n    date_format: str | None = None\n    datetime_format: str | None = None\n    is_optional: bool | None = False\n    str_to_var: Callable | None = None\n    var_to_str: Callable | None = None\n\n    def __post_init__(self):\n        has_date_converter = self.date_format is not None\n        has_datetime_converter = self.datetime_format is not None\n        has_custom_converter = self.var_to_str is not None or self.str_to_var is not None\n        active_converters_num = sum([has_date_converter, has_datetime_converter, has_custom_converter])\n        if active_converters_num &gt; 1:\n            raise ValueError(f\"Maximum one field converter is allowed, but {active_converters_num} were found\")\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced\n        :return: An FieldConf object with the attributes replaced\n        \"\"\"\n        field_conf = replace(self, **kwargs)\n        return field_conf\n</code></pre>"},{"location":"reference/andar/#andar.FieldConf.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced :return: An FieldConf object with the attributes replaced</p> Source code in <code>andar/field_conf.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced\n    :return: An FieldConf object with the attributes replaced\n    \"\"\"\n    field_conf = replace(self, **kwargs)\n    return field_conf\n</code></pre>"},{"location":"reference/andar/#andar.PathModel","title":"<code>PathModel</code>","text":"<p>PathModel allows to define, build and parse templated file paths</p> <p>It defines a path via a template and its fields. Once instantiated, it allows to build new paths and to parse path strings to recover individual fields.</p> Source code in <code>andar/path_model.py</code> <pre><code>class PathModel:\n    \"\"\"\n    PathModel allows to define, build and parse templated file paths\n\n    It defines a path via a template and its fields. Once instantiated, it allows to build new paths\n    and to parse path strings to recover individual fields.\n\n    \"\"\"\n\n    template: str\n    fields: dict[str, FieldConf]\n    default_field: FieldConf\n    parent_template: str\n    _dir_sep: str = \"/\"\n\n    def __init__(\n        self,\n        template: str,\n        parent_template: str | None = None,\n        fields: dict[str, FieldConf] | None = None,\n        default_field: FieldConf | None = None,\n    ):\n        self.template = template\n\n        if parent_template is None:\n            parent_template = os.path.dirname(self.template)\n        check_parent_path_template(template, parent_template)\n        self.parent_template = parent_template\n\n        if default_field is None:\n            default_field = FieldConf()\n        self.default_field = default_field\n\n        new_fields = {}\n        template_field_names = get_template_fields_names(template)\n        for field_name in template_field_names:\n            new_fields[field_name] = default_field\n\n        if fields is not None:\n            new_fields.update(fields)\n        self.fields = new_fields\n\n        new_field_names = list(new_fields.keys())\n        check_expected_fields(template_field_names, new_field_names)\n\n    def __repr__(self):\n        return f\"&lt;Template: '{self.template}'&gt;\\n&lt;Fields: {self.fields}&gt;\"\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n        :return: A PathModel instance\n        \"\"\"\n        default_parent_template = None\n        if \"template\" not in kwargs:\n            kwargs[\"template\"] = self.template\n            default_parent_template = self.parent_template\n        if \"parent_template\" not in kwargs:\n            kwargs[\"parent_template\"] = default_parent_template\n        if \"fields\" not in kwargs:\n            kwargs[\"fields\"] = self.fields\n        if \"default_field\" not in kwargs:\n            kwargs[\"default_field\"] = self.default_field\n\n        return self.__class__(**kwargs)\n\n    def update(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object updating attributes with the given keyword arguments\n        :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                       Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                       be removed.\n        :return: A PathModel instance\n        \"\"\"\n        fields = self.fields.copy()\n        if \"fields\" in kwargs:\n            fields.update(kwargs[\"fields\"])\n            fields_names = list(fields.keys())\n            [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n            kwargs[\"fields\"] = fields\n        return self.replace(**kwargs)\n\n    def __call__(self, **kwargs) -&gt; Self:\n        if not kwargs:\n            return self\n        return self.replace(**kwargs)\n\n    def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n        \"\"\"\n        Parse a file path\n\n        :param file_path: String to be parsed.\n        :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n        :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n                 string (or converted object)\n        \"\"\"\n        ds = self._dir_sep\n        path_template = self.template\n        path_template = path_template.replace(r\".\", r\"\\.\")\n        pattern_dict = {}\n        for field_name, field_conf in self.fields.items():\n            field_pattern = field_conf.pattern\n            if field_conf.is_optional:\n                field_pattern = f\"{field_pattern}|\"\n                # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n                field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n                optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n                path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n            pattern_dict[field_name] = field_pattern\n        parsed_fields = parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n        processed_fields = process_parsed_fields_values(self.fields, parsed_fields)\n        return processed_fields\n\n    @classmethod\n    def _get_path(\n        cls,\n        template: str,\n        fields_conf: dict[str, FieldConf],\n        fields_values_dict: dict[str, Any],\n    ) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param template: A template that follows string.Formatter() syntax.\n        :param fields_conf: Dictionary of fields configurations, where keys are field names and values are FieldConf\n                            instances.\n        :param fields_values_dict: Input parameters dict that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        fields_values_dict = fields_values_dict.copy()\n        template_field_names = get_template_fields_names(template)\n        missing_field_names = [field for field in template_field_names if field not in fields_values_dict]\n\n        for field_name in missing_field_names:\n            is_optional = fields_conf[field_name].is_optional\n            if is_optional:\n                fields_values_dict[field_name] = None\n\n        given_field_names = list(fields_values_dict.keys())\n        check_expected_fields(template_field_names, given_field_names)\n        fields_values_dict = prepare_fields_values(fields_values_dict, fields_conf)\n        new_path = template.format(**fields_values_dict)\n        new_path = os.path.normpath(new_path)\n        return new_path\n\n    def get_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n\n    def get_parent_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate parent path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                       parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                       updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                       an error will be raised.\n        :return: String. Parent path.\n        \"\"\"\n\n        # remove all fields not present in parent template\n        parent_fields = self.fields.copy()\n        fields_names = get_template_fields_names(self.template)\n        parent_fields_names = get_template_fields_names(self.parent_template)\n\n        # Drop fields corresponding to filename\n        for field in fields_names:\n            if field not in parent_fields_names:\n                parent_fields.pop(field)\n\n        # Make dynamic the parent path creation, so the last fields can be omitted\n        # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n        new_parent_template = self.parent_template\n        dynamic_fields_names = []\n        missing_kwarg_name = None\n        for parent_field_name in parent_fields_names:\n            is_optional = parent_fields[parent_field_name].is_optional\n            if parent_field_name not in kwargs and not is_optional:\n                # keep known (left) part of parent_template and drop the rest\n                missing_kwarg_name = parent_field_name\n                new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n                break\n            dynamic_fields_names.append(parent_field_name)\n\n        # Drop fields corresponding to last arguments that were skipped\n        parent_fields_names = list(parent_fields.keys())\n        for field_name in parent_fields_names:\n            if field_name not in dynamic_fields_names:\n                parent_fields.pop(field_name)\n\n        # Check for unnecessary extra args\n        extra_kwargs = {}\n        for field_name in kwargs:\n            if field_name not in parent_fields:\n                extra_kwargs[field_name] = kwargs[field_name]\n        if missing_kwarg_name and extra_kwargs:\n            raise ValueError(\n                f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n                f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n            )\n\n        return self._get_path(\n            template=new_parent_template,\n            fields_conf=parent_fields,\n            fields_values_dict=kwargs,\n        )\n\n    def assert_path_bijection(self, test_path: str):\n        \"\"\"\n        Assert path bijection\n\n        It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n        :param test_path: Path string to be tested\n        \"\"\"\n        parsed_fields = self.parse_path(test_path, raise_error=True)\n        result_test_path = self.get_path(**parsed_fields)\n        assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n\n    def assert_fields_bijection(self, test_fields: dict[str, Any]):\n        \"\"\"\n        Assert fields bijection\n\n        It tries to recover the same initial input after processing once with get_path and parse_file_path\n        This method is the preferred way of checking if the PathModel was well-defined.\n\n        :param test_fields: Dictionary of fields to be tested\n        \"\"\"\n        test_path = self.get_path(**test_fields)\n        result_parsed_fields = self.parse_path(test_path, raise_error=True)\n        assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.assert_fields_bijection","title":"<code>assert_fields_bijection(test_fields)</code>","text":"<p>Assert fields bijection</p> <p>It tries to recover the same initial input after processing once with get_path and parse_file_path This method is the preferred way of checking if the PathModel was well-defined.</p> <p>:param test_fields: Dictionary of fields to be tested</p> Source code in <code>andar/path_model.py</code> <pre><code>def assert_fields_bijection(self, test_fields: dict[str, Any]):\n    \"\"\"\n    Assert fields bijection\n\n    It tries to recover the same initial input after processing once with get_path and parse_file_path\n    This method is the preferred way of checking if the PathModel was well-defined.\n\n    :param test_fields: Dictionary of fields to be tested\n    \"\"\"\n    test_path = self.get_path(**test_fields)\n    result_parsed_fields = self.parse_path(test_path, raise_error=True)\n    assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.assert_path_bijection","title":"<code>assert_path_bijection(test_path)</code>","text":"<p>Assert path bijection</p> <p>It tries to recover the same initial input after processing once with parse_file_path and get_path</p> <p>:param test_path: Path string to be tested</p> Source code in <code>andar/path_model.py</code> <pre><code>def assert_path_bijection(self, test_path: str):\n    \"\"\"\n    Assert path bijection\n\n    It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n    :param test_path: Path string to be tested\n    \"\"\"\n    parsed_fields = self.parse_path(test_path, raise_error=True)\n    result_test_path = self.get_path(**parsed_fields)\n    assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.get_parent_path","title":"<code>get_parent_path(**kwargs)</code>","text":"<p>Generate parent path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. They are used in the order of                parent_template, if the last argument(s) are omitted, the parent_template will be dynamically                updated to a shorter version. If an argument in the middle is omitted, and it is not optional,                an error will be raised. :return: String. Parent path.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_parent_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate parent path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                   parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                   updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                   an error will be raised.\n    :return: String. Parent path.\n    \"\"\"\n\n    # remove all fields not present in parent template\n    parent_fields = self.fields.copy()\n    fields_names = get_template_fields_names(self.template)\n    parent_fields_names = get_template_fields_names(self.parent_template)\n\n    # Drop fields corresponding to filename\n    for field in fields_names:\n        if field not in parent_fields_names:\n            parent_fields.pop(field)\n\n    # Make dynamic the parent path creation, so the last fields can be omitted\n    # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n    new_parent_template = self.parent_template\n    dynamic_fields_names = []\n    missing_kwarg_name = None\n    for parent_field_name in parent_fields_names:\n        is_optional = parent_fields[parent_field_name].is_optional\n        if parent_field_name not in kwargs and not is_optional:\n            # keep known (left) part of parent_template and drop the rest\n            missing_kwarg_name = parent_field_name\n            new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n            break\n        dynamic_fields_names.append(parent_field_name)\n\n    # Drop fields corresponding to last arguments that were skipped\n    parent_fields_names = list(parent_fields.keys())\n    for field_name in parent_fields_names:\n        if field_name not in dynamic_fields_names:\n            parent_fields.pop(field_name)\n\n    # Check for unnecessary extra args\n    extra_kwargs = {}\n    for field_name in kwargs:\n        if field_name not in parent_fields:\n            extra_kwargs[field_name] = kwargs[field_name]\n    if missing_kwarg_name and extra_kwargs:\n        raise ValueError(\n            f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n            f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n        )\n\n    return self._get_path(\n        template=new_parent_template,\n        fields_conf=parent_fields,\n        fields_values_dict=kwargs,\n    )\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.get_path","title":"<code>get_path(**kwargs)</code>","text":"<p>Generate path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. :return: String. Path.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values.\n    :return: String. Path.\n    \"\"\"\n    return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.parse_path","title":"<code>parse_path(file_path, raise_error=False)</code>","text":"<p>Parse a file path</p> <p>:param file_path: String to be parsed. :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None. :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed          string (or converted object)</p> Source code in <code>andar/path_model.py</code> <pre><code>def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n    \"\"\"\n    Parse a file path\n\n    :param file_path: String to be parsed.\n    :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n    :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n             string (or converted object)\n    \"\"\"\n    ds = self._dir_sep\n    path_template = self.template\n    path_template = path_template.replace(r\".\", r\"\\.\")\n    pattern_dict = {}\n    for field_name, field_conf in self.fields.items():\n        field_pattern = field_conf.pattern\n        if field_conf.is_optional:\n            field_pattern = f\"{field_pattern}|\"\n            # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n            field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n            optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n            path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n        pattern_dict[field_name] = field_pattern\n    parsed_fields = parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n    processed_fields = process_parsed_fields_values(self.fields, parsed_fields)\n    return processed_fields\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation :return: A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n    :return: A PathModel instance\n    \"\"\"\n    default_parent_template = None\n    if \"template\" not in kwargs:\n        kwargs[\"template\"] = self.template\n        default_parent_template = self.parent_template\n    if \"parent_template\" not in kwargs:\n        kwargs[\"parent_template\"] = default_parent_template\n    if \"fields\" not in kwargs:\n        kwargs[\"fields\"] = self.fields\n    if \"default_field\" not in kwargs:\n        kwargs[\"default_field\"] = self.default_field\n\n    return self.__class__(**kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.PathModel.update","title":"<code>update(**kwargs)</code>","text":"<p>Creates a copy of the current object updating attributes with the given keyword arguments :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.                Fields set to None, will be reset to default, if it is no longer present on the template, it will                be removed. :return: A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def update(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object updating attributes with the given keyword arguments\n    :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                   Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                   be removed.\n    :return: A PathModel instance\n    \"\"\"\n    fields = self.fields.copy()\n    if \"fields\" in kwargs:\n        fields.update(kwargs[\"fields\"])\n        fields_names = list(fields.keys())\n        [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n        kwargs[\"fields\"] = fields\n    return self.replace(**kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.SafePatterns","title":"<code>SafePatterns</code>","text":"<p>Non-greedy patterns</p> Source code in <code>andar/field_conf.py</code> <pre><code>class SafePatterns:\n    \"\"\"\n    Non-greedy patterns\n    \"\"\"\n\n    FILENAME = r\"[-_.a-zA-Z0-9]+?\"  # include filename separators: -_.\n    DIRPATH = r\"[-_.a-zA-Z0-9/]+?\"  # include filename separators: -_. and directory separator: /\n    FIELD = r\"[a-zA-Z0-9]+?\"  # without separator characters\n    EXTENSION = r\"[.a-zA-Z0-9]+?\"  # include dots for sub extensions as 'tar.gz'\n</code></pre>"},{"location":"reference/andar/check_utils/","title":"check_utils","text":""},{"location":"reference/andar/check_utils/#andar.check_utils","title":"<code>andar.check_utils</code>","text":""},{"location":"reference/andar/check_utils/#andar.check_utils.check_expected_fields","title":"<code>check_expected_fields(expected_field_names, new_field_names)</code>","text":"<p>Check if fields in the expected_field_names are coherent with new_field_names</p> <p>:param expected_field_names: The expected list of field names. :param new_field_names: The new list of field names to be validated.</p> Source code in <code>andar/check_utils.py</code> <pre><code>def check_expected_fields(expected_field_names: list[str], new_field_names: list[str]) -&gt; None:\n    \"\"\"\n    Check if fields in the expected_field_names are coherent with new_field_names\n\n    :param expected_field_names: The expected list of field names.\n    :param new_field_names: The new list of field names to be validated.\n    \"\"\"\n    invalid_fields = [f for f in new_field_names if f not in expected_field_names]\n    if invalid_fields:\n        raise ValueError(\n            f\"Invalid fields: {invalid_fields} they do not exist in expected field list: '{expected_field_names}'\"\n        )\n\n    missing_fields = [f for f in expected_field_names if f not in new_field_names]\n    if missing_fields:\n        raise ValueError(\n            f\"Missing fields: {missing_fields} they are required in expected field list: '{expected_field_names}'\"\n        )\n</code></pre>"},{"location":"reference/andar/check_utils/#andar.check_utils.check_parent_path_template","title":"<code>check_parent_path_template(path_template, parent_path_template)</code>","text":"<p>Check if parent_path_template is coherent with path_template</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.</p> Source code in <code>andar/check_utils.py</code> <pre><code>def check_parent_path_template(path_template: str, parent_path_template: str) -&gt; None:\n    \"\"\"\n    Check if parent_path_template is coherent with path_template\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.\n    \"\"\"\n    if parent_path_template not in path_template:\n        raise ValueError(\n            f\"path_template: '{path_template}' does not match with parent_path_template: \"\n            f\"'{parent_path_template}'. parent_path_template must be a substring of path_template\"\n        )\n</code></pre>"},{"location":"reference/andar/field_conf/","title":"field_conf","text":""},{"location":"reference/andar/field_conf/#andar.field_conf","title":"<code>andar.field_conf</code>","text":""},{"location":"reference/andar/field_conf/#andar.field_conf.FieldConf","title":"<code>FieldConf</code>  <code>dataclass</code>","text":"<p>FieldConf allows to configure how a path field is validated, parsed and processed</p> <p>:param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using                 parse_path. By default, it used SafePatterns.FILENAME. :param date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a                     string or a datetime object that can be formated to an input string for a the given template.                     They are also used for validating the parsed field when using parse_path and for defining how                     to cast the string (to date or to datetime, depending on the argument that was used). :param datetime_format: See description of date_format parameter. :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)                     or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must                     be constrained, otherwise the PathModel class may have an unexpected behaviour.                     For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.</p> Source code in <code>andar/field_conf.py</code> <pre><code>@dataclass\nclass FieldConf:\n    \"\"\"\n    FieldConf allows to configure how a path field is validated, parsed and processed\n\n    :param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using\n                    parse_path. By default, it used SafePatterns.FILENAME.\n    :param date_format: date_format and datetime_format are used in get_path and get_parent_path for accepting either a\n                        string or a datetime object that can be formated to an input string for a the given template.\n                        They are also used for validating the parsed field when using parse_path and for defining how\n                        to cast the string (to date or to datetime, depending on the argument that was used).\n    :param datetime_format: See description of date_format parameter.\n    :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)\n                        or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must\n                        be constrained, otherwise the PathModel class may have an unexpected behaviour.\n                        For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True.\n    \"\"\"\n\n    pattern: str = SafePatterns.FILENAME\n    date_format: str | None = None\n    datetime_format: str | None = None\n    is_optional: bool | None = False\n    str_to_var: Callable | None = None\n    var_to_str: Callable | None = None\n\n    def __post_init__(self):\n        has_date_converter = self.date_format is not None\n        has_datetime_converter = self.datetime_format is not None\n        has_custom_converter = self.var_to_str is not None or self.str_to_var is not None\n        active_converters_num = sum([has_date_converter, has_datetime_converter, has_custom_converter])\n        if active_converters_num &gt; 1:\n            raise ValueError(f\"Maximum one field converter is allowed, but {active_converters_num} were found\")\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced\n        :return: An FieldConf object with the attributes replaced\n        \"\"\"\n        field_conf = replace(self, **kwargs)\n        return field_conf\n</code></pre>"},{"location":"reference/andar/field_conf/#andar.field_conf.FieldConf.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced :return: An FieldConf object with the attributes replaced</p> Source code in <code>andar/field_conf.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced\n    :return: An FieldConf object with the attributes replaced\n    \"\"\"\n    field_conf = replace(self, **kwargs)\n    return field_conf\n</code></pre>"},{"location":"reference/andar/field_conf/#andar.field_conf.SafePatterns","title":"<code>SafePatterns</code>","text":"<p>Non-greedy patterns</p> Source code in <code>andar/field_conf.py</code> <pre><code>class SafePatterns:\n    \"\"\"\n    Non-greedy patterns\n    \"\"\"\n\n    FILENAME = r\"[-_.a-zA-Z0-9]+?\"  # include filename separators: -_.\n    DIRPATH = r\"[-_.a-zA-Z0-9/]+?\"  # include filename separators: -_. and directory separator: /\n    FIELD = r\"[a-zA-Z0-9]+?\"  # without separator characters\n    EXTENSION = r\"[.a-zA-Z0-9]+?\"  # include dots for sub extensions as 'tar.gz'\n</code></pre>"},{"location":"reference/andar/parser_utils/","title":"parser_utils","text":""},{"location":"reference/andar/parser_utils/#andar.parser_utils","title":"<code>andar.parser_utils</code>","text":"<p>Module containing utility functions</p>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.assign_groupname_pattern_dict","title":"<code>assign_groupname_pattern_dict(pattern_dict)</code>","text":"<p>Assign a group name to each regex pattern present in the given dictionary</p> <p>:param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not                         check if the pattern already have a group name assign. :return: A dictionary where the patterns have been assigned a group name.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def assign_groupname_pattern_dict(pattern_dict: dict[str:str]) -&gt; dict[str:str]:\n    \"\"\"\n    Assign a group name to each regex pattern present in the given dictionary\n\n    :param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not\n                            check if the pattern already have a group name assign.\n    :return: A dictionary where the patterns have been assigned a group name.\n    \"\"\"\n    named_pattern_dict = {}\n    for field, pattern in pattern_dict.items():\n        named_pattern_dict[field] = f\"(?P&lt;{field}&gt;{pattern})\"\n    return named_pattern_dict\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.get_template_fields_names","title":"<code>get_template_fields_names(path_template)</code>","text":"<p>Get fields names from path template string</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :return: List. Template fields names.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def get_template_fields_names(path_template: str) -&gt; list[str]:\n    \"\"\"\n    Get fields names from path template string\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :return: List. Template fields names.\n    \"\"\"\n    parsed_field_tuples = list(string.Formatter().parse(path_template))\n    template_fields_names = [name for (text, name, spec, conv) in parsed_field_tuples if name is not None]\n    return template_fields_names\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.parse_fields","title":"<code>parse_fields(_string, template, pattern_dict, raise_error=False)</code>","text":"<p>Parse a string using a template and a patterns dictionary</p> <p>Example: filename_template = \"{prefix}_{name}.{extension}\" pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"} filename = \"0001_example.json\" parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict) invalid_filename = \"invalid_example.json\" parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)</p> <p>:param _string: String to be parsed. :param template: A template that follows string.Formatter() syntax. :param pattern_dict: A dictionary where each key represent a field of the template and each value is the                         corresponding regex pattern :param raise_error: Raise an exception if the path is not valid. If False, it returns None. :return: A dictionary of parsed fields.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def parse_fields(\n    _string: str,\n    template: str,\n    pattern_dict: dict[str:str],\n    raise_error: bool = False,\n) -&gt; dict[str:str]:\n    \"\"\"\n    Parse a string using a template and a patterns dictionary\n\n    Example:\n    filename_template = \"{prefix}_{name}.{extension}\"\n    pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"}\n    filename = \"0001_example.json\"\n    parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict)\n    invalid_filename = \"invalid_example.json\"\n    parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)\n\n    :param _string: String to be parsed.\n    :param template: A template that follows string.Formatter() syntax.\n    :param pattern_dict: A dictionary where each key represent a field of the template and each value is the\n                            corresponding regex pattern\n    :param raise_error: Raise an exception if the path is not valid. If False, it returns None.\n    :return: A dictionary of parsed fields.\n    \"\"\"\n    template_field_names = get_template_fields_names(template)\n    pattern_field_names = list(pattern_dict.keys())\n    check_expected_fields(template_field_names, pattern_field_names)\n\n    # Deduplicate repeated fields of pattern_dict:\n    # for example the template \"/{base_path}/{asset_name}/{asset_name}_{suffix}\"\n    # will become \"/{base_path}/{asset_name__0}/{asset_name__1}_{suffix}\"\n    # and the dict {\"base_path\": r\"\\w+\", \"asset_name\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    # will become {\"base_path\": r\"\\w+\", \"asset_name__0\": r\"\\w+\", \"asset_name__1\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    unique_fields = list(set(template_field_names))\n    deduplicated_fields_dict = {}\n    new_pattern_dict = {}\n    new_template = template\n    for field_name in unique_fields:\n        field_count = len([f for f in template_field_names if f == field_name])\n        if field_count == 1:\n            new_pattern_dict[field_name] = pattern_dict[field_name]\n            continue\n        deduplicated_list = []\n        for idx in range(field_count):\n            new_field_name = field_name + f\"__{idx}\"\n            deduplicated_list.append(new_field_name)\n            new_pattern_dict[new_field_name] = pattern_dict[field_name]\n            new_template = new_template.replace(\"{\" + field_name + \"}\", \"{\" + new_field_name + \"}\", 1)\n        deduplicated_fields_dict[field_name] = deduplicated_list\n\n    has_duplicates = pattern_dict != new_pattern_dict\n    if has_duplicates:\n        pattern_dict = new_pattern_dict\n        template = new_template\n\n    # Build full pattern string\n    named_pattern_dict = assign_groupname_pattern_dict(pattern_dict)\n    path_pattern = template.format(**named_pattern_dict)\n    path_pattern = f\"^{path_pattern}$\"  # match the full string\n    match = re.match(path_pattern, _string)\n    if not match:\n        if raise_error:\n            raise ValueError(f\"Invalid string '{_string}', expected pattern: '{path_pattern}'\")\n        return None\n    parsed_fields_dict = match.groupdict()\n\n    # Fusion deduplicated fields:\n    # it will raise an error if the deduplicate fields have multiples values\n    # for example this parsed dict will raise an error because asset_name__0 and asset_name__1 should be equal:\n    # {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"other_asset\", \"suffix\": \"001\"}\n    # if the deduplicated fields are coherent they will be fusion and renamed to its original name:\n    # for example {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"my_asset\", \"suffix\": \"001\"}\n    # to {\"base_path\": \"folder\", \"asset_name\": \"my_asset\", \"suffix\": \"001\"}\n    for original_field_name, deduplicated_list in deduplicated_fields_dict.items():\n        parsed_field_values = [parsed_fields_dict.pop(f) for f in deduplicated_list]\n        unique_parsed_field_values = list(set(parsed_field_values))\n        are_duplicated_unique = len(unique_parsed_field_values) == 1\n        if not are_duplicated_unique:\n            raise ValueError(\n                f\"More than one value was found for repeated field '{original_field_name}': {parsed_field_values}\"\n            )\n        parsed_fields_dict[original_field_name] = unique_parsed_field_values[0]\n\n    return parsed_fields_dict\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.prepare_fields_values","title":"<code>prepare_fields_values(fields_values_dict, fields_conf)</code>","text":"<p>Prepare fields values for this path :param fields_values_dict: Dictionary of fields values :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf) :return: A dictionary of fields where the values were converted to strings.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def prepare_fields_values(fields_values_dict: dict[str:Any], fields_conf: dict[str, FieldConf]) -&gt; dict[str:str]:\n    \"\"\"\n    Prepare fields values for this path\n    :param fields_values_dict: Dictionary of fields values\n    :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf)\n    :return: A dictionary of fields where the values were converted to strings.\n    \"\"\"\n    new_fields_values_dict = {}\n    for field_name, field_value in fields_values_dict.items():\n        if field_name not in fields_conf:\n            print(f\"skipping field '{field_name}'\")\n            continue\n        field_conf = fields_conf[field_name]\n\n        if field_value is None and field_conf.is_optional:\n            new_fields_values_dict[field_name] = \"\"\n            continue\n\n        if field_conf.date_format is not None:\n            new_field_value = field_value.strftime(field_conf.date_format)\n        elif field_conf.datetime_format is not None:\n            new_field_value = field_value.strftime(field_conf.datetime_format)\n        elif field_conf.var_to_str is not None:\n            new_field_value = field_conf.var_to_str(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        result = re.match(field_pattern, new_field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{new_field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n        new_fields_values_dict[field_name] = new_field_value\n    return new_fields_values_dict\n</code></pre>"},{"location":"reference/andar/parser_utils/#andar.parser_utils.process_parsed_fields_values","title":"<code>process_parsed_fields_values(fields_conf, parsed_fields)</code>","text":"<p>Process fields values dictionary obtained from parsing a file path</p> <p>:param parsed_fields: A dictionary of parsed fields values in string format. :return: A processed dictionary of fields with converted values depending on each FieldConf definition.</p> Source code in <code>andar/parser_utils.py</code> <pre><code>def process_parsed_fields_values(fields_conf: dict[str, FieldConf], parsed_fields: dict[str:str]) -&gt; dict[str:Any]:\n    \"\"\"\n    Process fields values dictionary obtained from parsing a file path\n\n    :param parsed_fields: A dictionary of parsed fields values in string format.\n    :return: A processed dictionary of fields with converted values depending on each FieldConf definition.\n    \"\"\"\n    new_parsed_fields = parsed_fields.copy()\n\n    for field_name, field_value in new_parsed_fields.items():\n        if field_name not in fields_conf:\n            raise ValueError(f\"Unknown field '{field_name}'. Valid fields are: {fields_conf.keys()}\")\n        field_conf = fields_conf[field_name]\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        if field_conf.is_optional:\n            field_pattern = f\"^{field_conf.pattern}|$\"\n        result = re.match(field_pattern, field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n\n        if field_conf.date_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.date_format).date()\n        elif field_conf.datetime_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.datetime_format)\n        elif field_conf.str_to_var is not None:\n            new_field_value = field_conf.str_to_var(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        if new_field_value == \"\" and field_conf.is_optional:\n            new_field_value = None\n\n        new_parsed_fields[field_name] = new_field_value\n    return new_parsed_fields\n</code></pre>"},{"location":"reference/andar/path_model/","title":"path_model","text":""},{"location":"reference/andar/path_model/#andar.path_model","title":"<code>andar.path_model</code>","text":""},{"location":"reference/andar/path_model/#andar.path_model.PathModel","title":"<code>PathModel</code>","text":"<p>PathModel allows to define, build and parse templated file paths</p> <p>It defines a path via a template and its fields. Once instantiated, it allows to build new paths and to parse path strings to recover individual fields.</p> Source code in <code>andar/path_model.py</code> <pre><code>class PathModel:\n    \"\"\"\n    PathModel allows to define, build and parse templated file paths\n\n    It defines a path via a template and its fields. Once instantiated, it allows to build new paths\n    and to parse path strings to recover individual fields.\n\n    \"\"\"\n\n    template: str\n    fields: dict[str, FieldConf]\n    default_field: FieldConf\n    parent_template: str\n    _dir_sep: str = \"/\"\n\n    def __init__(\n        self,\n        template: str,\n        parent_template: str | None = None,\n        fields: dict[str, FieldConf] | None = None,\n        default_field: FieldConf | None = None,\n    ):\n        self.template = template\n\n        if parent_template is None:\n            parent_template = os.path.dirname(self.template)\n        check_parent_path_template(template, parent_template)\n        self.parent_template = parent_template\n\n        if default_field is None:\n            default_field = FieldConf()\n        self.default_field = default_field\n\n        new_fields = {}\n        template_field_names = get_template_fields_names(template)\n        for field_name in template_field_names:\n            new_fields[field_name] = default_field\n\n        if fields is not None:\n            new_fields.update(fields)\n        self.fields = new_fields\n\n        new_field_names = list(new_fields.keys())\n        check_expected_fields(template_field_names, new_field_names)\n\n    def __repr__(self):\n        return f\"&lt;Template: '{self.template}'&gt;\\n&lt;Fields: {self.fields}&gt;\"\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n        :return: A PathModel instance\n        \"\"\"\n        default_parent_template = None\n        if \"template\" not in kwargs:\n            kwargs[\"template\"] = self.template\n            default_parent_template = self.parent_template\n        if \"parent_template\" not in kwargs:\n            kwargs[\"parent_template\"] = default_parent_template\n        if \"fields\" not in kwargs:\n            kwargs[\"fields\"] = self.fields\n        if \"default_field\" not in kwargs:\n            kwargs[\"default_field\"] = self.default_field\n\n        return self.__class__(**kwargs)\n\n    def update(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object updating attributes with the given keyword arguments\n        :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                       Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                       be removed.\n        :return: A PathModel instance\n        \"\"\"\n        fields = self.fields.copy()\n        if \"fields\" in kwargs:\n            fields.update(kwargs[\"fields\"])\n            fields_names = list(fields.keys())\n            [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n            kwargs[\"fields\"] = fields\n        return self.replace(**kwargs)\n\n    def __call__(self, **kwargs) -&gt; Self:\n        if not kwargs:\n            return self\n        return self.replace(**kwargs)\n\n    def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n        \"\"\"\n        Parse a file path\n\n        :param file_path: String to be parsed.\n        :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n        :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n                 string (or converted object)\n        \"\"\"\n        ds = self._dir_sep\n        path_template = self.template\n        path_template = path_template.replace(r\".\", r\"\\.\")\n        pattern_dict = {}\n        for field_name, field_conf in self.fields.items():\n            field_pattern = field_conf.pattern\n            if field_conf.is_optional:\n                field_pattern = f\"{field_pattern}|\"\n                # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n                field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n                optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n                path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n            pattern_dict[field_name] = field_pattern\n        parsed_fields = parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n        processed_fields = process_parsed_fields_values(self.fields, parsed_fields)\n        return processed_fields\n\n    @classmethod\n    def _get_path(\n        cls,\n        template: str,\n        fields_conf: dict[str, FieldConf],\n        fields_values_dict: dict[str, Any],\n    ) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param template: A template that follows string.Formatter() syntax.\n        :param fields_conf: Dictionary of fields configurations, where keys are field names and values are FieldConf\n                            instances.\n        :param fields_values_dict: Input parameters dict that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        fields_values_dict = fields_values_dict.copy()\n        template_field_names = get_template_fields_names(template)\n        missing_field_names = [field for field in template_field_names if field not in fields_values_dict]\n\n        for field_name in missing_field_names:\n            is_optional = fields_conf[field_name].is_optional\n            if is_optional:\n                fields_values_dict[field_name] = None\n\n        given_field_names = list(fields_values_dict.keys())\n        check_expected_fields(template_field_names, given_field_names)\n        fields_values_dict = prepare_fields_values(fields_values_dict, fields_conf)\n        new_path = template.format(**fields_values_dict)\n        new_path = os.path.normpath(new_path)\n        return new_path\n\n    def get_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n\n    def get_parent_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate parent path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                       parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                       updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                       an error will be raised.\n        :return: String. Parent path.\n        \"\"\"\n\n        # remove all fields not present in parent template\n        parent_fields = self.fields.copy()\n        fields_names = get_template_fields_names(self.template)\n        parent_fields_names = get_template_fields_names(self.parent_template)\n\n        # Drop fields corresponding to filename\n        for field in fields_names:\n            if field not in parent_fields_names:\n                parent_fields.pop(field)\n\n        # Make dynamic the parent path creation, so the last fields can be omitted\n        # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n        new_parent_template = self.parent_template\n        dynamic_fields_names = []\n        missing_kwarg_name = None\n        for parent_field_name in parent_fields_names:\n            is_optional = parent_fields[parent_field_name].is_optional\n            if parent_field_name not in kwargs and not is_optional:\n                # keep known (left) part of parent_template and drop the rest\n                missing_kwarg_name = parent_field_name\n                new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n                break\n            dynamic_fields_names.append(parent_field_name)\n\n        # Drop fields corresponding to last arguments that were skipped\n        parent_fields_names = list(parent_fields.keys())\n        for field_name in parent_fields_names:\n            if field_name not in dynamic_fields_names:\n                parent_fields.pop(field_name)\n\n        # Check for unnecessary extra args\n        extra_kwargs = {}\n        for field_name in kwargs:\n            if field_name not in parent_fields:\n                extra_kwargs[field_name] = kwargs[field_name]\n        if missing_kwarg_name and extra_kwargs:\n            raise ValueError(\n                f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n                f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n            )\n\n        return self._get_path(\n            template=new_parent_template,\n            fields_conf=parent_fields,\n            fields_values_dict=kwargs,\n        )\n\n    def assert_path_bijection(self, test_path: str):\n        \"\"\"\n        Assert path bijection\n\n        It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n        :param test_path: Path string to be tested\n        \"\"\"\n        parsed_fields = self.parse_path(test_path, raise_error=True)\n        result_test_path = self.get_path(**parsed_fields)\n        assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n\n    def assert_fields_bijection(self, test_fields: dict[str, Any]):\n        \"\"\"\n        Assert fields bijection\n\n        It tries to recover the same initial input after processing once with get_path and parse_file_path\n        This method is the preferred way of checking if the PathModel was well-defined.\n\n        :param test_fields: Dictionary of fields to be tested\n        \"\"\"\n        test_path = self.get_path(**test_fields)\n        result_parsed_fields = self.parse_path(test_path, raise_error=True)\n        assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.assert_fields_bijection","title":"<code>assert_fields_bijection(test_fields)</code>","text":"<p>Assert fields bijection</p> <p>It tries to recover the same initial input after processing once with get_path and parse_file_path This method is the preferred way of checking if the PathModel was well-defined.</p> <p>:param test_fields: Dictionary of fields to be tested</p> Source code in <code>andar/path_model.py</code> <pre><code>def assert_fields_bijection(self, test_fields: dict[str, Any]):\n    \"\"\"\n    Assert fields bijection\n\n    It tries to recover the same initial input after processing once with get_path and parse_file_path\n    This method is the preferred way of checking if the PathModel was well-defined.\n\n    :param test_fields: Dictionary of fields to be tested\n    \"\"\"\n    test_path = self.get_path(**test_fields)\n    result_parsed_fields = self.parse_path(test_path, raise_error=True)\n    assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.assert_path_bijection","title":"<code>assert_path_bijection(test_path)</code>","text":"<p>Assert path bijection</p> <p>It tries to recover the same initial input after processing once with parse_file_path and get_path</p> <p>:param test_path: Path string to be tested</p> Source code in <code>andar/path_model.py</code> <pre><code>def assert_path_bijection(self, test_path: str):\n    \"\"\"\n    Assert path bijection\n\n    It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n    :param test_path: Path string to be tested\n    \"\"\"\n    parsed_fields = self.parse_path(test_path, raise_error=True)\n    result_test_path = self.get_path(**parsed_fields)\n    assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.get_parent_path","title":"<code>get_parent_path(**kwargs)</code>","text":"<p>Generate parent path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. They are used in the order of                parent_template, if the last argument(s) are omitted, the parent_template will be dynamically                updated to a shorter version. If an argument in the middle is omitted, and it is not optional,                an error will be raised. :return: String. Parent path.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_parent_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate parent path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                   parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                   updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                   an error will be raised.\n    :return: String. Parent path.\n    \"\"\"\n\n    # remove all fields not present in parent template\n    parent_fields = self.fields.copy()\n    fields_names = get_template_fields_names(self.template)\n    parent_fields_names = get_template_fields_names(self.parent_template)\n\n    # Drop fields corresponding to filename\n    for field in fields_names:\n        if field not in parent_fields_names:\n            parent_fields.pop(field)\n\n    # Make dynamic the parent path creation, so the last fields can be omitted\n    # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n    new_parent_template = self.parent_template\n    dynamic_fields_names = []\n    missing_kwarg_name = None\n    for parent_field_name in parent_fields_names:\n        is_optional = parent_fields[parent_field_name].is_optional\n        if parent_field_name not in kwargs and not is_optional:\n            # keep known (left) part of parent_template and drop the rest\n            missing_kwarg_name = parent_field_name\n            new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n            break\n        dynamic_fields_names.append(parent_field_name)\n\n    # Drop fields corresponding to last arguments that were skipped\n    parent_fields_names = list(parent_fields.keys())\n    for field_name in parent_fields_names:\n        if field_name not in dynamic_fields_names:\n            parent_fields.pop(field_name)\n\n    # Check for unnecessary extra args\n    extra_kwargs = {}\n    for field_name in kwargs:\n        if field_name not in parent_fields:\n            extra_kwargs[field_name] = kwargs[field_name]\n    if missing_kwarg_name and extra_kwargs:\n        raise ValueError(\n            f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n            f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n        )\n\n    return self._get_path(\n        template=new_parent_template,\n        fields_conf=parent_fields,\n        fields_values_dict=kwargs,\n    )\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.get_path","title":"<code>get_path(**kwargs)</code>","text":"<p>Generate path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. :return: String. Path.</p> Source code in <code>andar/path_model.py</code> <pre><code>def get_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values.\n    :return: String. Path.\n    \"\"\"\n    return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.parse_path","title":"<code>parse_path(file_path, raise_error=False)</code>","text":"<p>Parse a file path</p> <p>:param file_path: String to be parsed. :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None. :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed          string (or converted object)</p> Source code in <code>andar/path_model.py</code> <pre><code>def parse_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n    \"\"\"\n    Parse a file path\n\n    :param file_path: String to be parsed.\n    :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n    :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n             string (or converted object)\n    \"\"\"\n    ds = self._dir_sep\n    path_template = self.template\n    path_template = path_template.replace(r\".\", r\"\\.\")\n    pattern_dict = {}\n    for field_name, field_conf in self.fields.items():\n        field_pattern = field_conf.pattern\n        if field_conf.is_optional:\n            field_pattern = f\"{field_pattern}|\"\n            # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n            field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n            optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n            path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n        pattern_dict[field_name] = field_pattern\n    parsed_fields = parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n    processed_fields = process_parsed_fields_values(self.fields, parsed_fields)\n    return processed_fields\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation :return: A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced, same arguments as used for PathModel instantiation\n    :return: A PathModel instance\n    \"\"\"\n    default_parent_template = None\n    if \"template\" not in kwargs:\n        kwargs[\"template\"] = self.template\n        default_parent_template = self.parent_template\n    if \"parent_template\" not in kwargs:\n        kwargs[\"parent_template\"] = default_parent_template\n    if \"fields\" not in kwargs:\n        kwargs[\"fields\"] = self.fields\n    if \"default_field\" not in kwargs:\n        kwargs[\"default_field\"] = self.default_field\n\n    return self.__class__(**kwargs)\n</code></pre>"},{"location":"reference/andar/path_model/#andar.path_model.PathModel.update","title":"<code>update(**kwargs)</code>","text":"<p>Creates a copy of the current object updating attributes with the given keyword arguments :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.                Fields set to None, will be reset to default, if it is no longer present on the template, it will                be removed. :return: A PathModel instance</p> Source code in <code>andar/path_model.py</code> <pre><code>def update(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object updating attributes with the given keyword arguments\n    :param kwargs: Attributes to be updated, same arguments as used for PathModel instantiation.\n                   Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                   be removed.\n    :return: A PathModel instance\n    \"\"\"\n    fields = self.fields.copy()\n    if \"fields\" in kwargs:\n        fields.update(kwargs[\"fields\"])\n        fields_names = list(fields.keys())\n        [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n        kwargs[\"fields\"] = fields\n    return self.replace(**kwargs)\n</code></pre>"}]}