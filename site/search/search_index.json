{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Andar Docs","text":"<p>Andar module implement a PathBuilder class that allows to define, create and parse templated paths.</p>"},{"location":"#project-overview","title":"Project Overview","text":""},{"location":"#example-usage","title":"Example usage:","text":"<pre><code>from andar import PathBuilder\n\n# Simple definition, using automatic definition of fields\nsimple_path_builder = PathBuilder(template=\"{base_folder}/{intermediate_folder}/{base_name}_{suffix}.{extension}\")\n\nresult_path = simple_path_builder.get_path(\n    base_folder=\"parent_folder\",\n    intermediate_folder=\"other_folder\",\n    base_name=\"mydata\",\n    suffix=\"2000-01-01\",\n    extension=\"csv\",\n)\nprint(result_path)  # \"parent_folder/other_folder/mydata_2000-01-01.csv\"\n\nresult_parent_path = simple_path_builder.get_parent_path(\n    base_folder=\"parent_folder\",\n    intermediate_folder=\"other_folder\",\n)\nprint(result_parent_path)  # \"parent_folder/other_folder\"\n\nfile_path = \"parent_folder/other_folder/mydata_2000-01-01.csv\"\nparsed_fields = simple_path_builder.parse_file_path(file_path)\nprint(parsed_fields)\n\n</code></pre>"},{"location":"reference/andar/","title":"andar","text":""},{"location":"reference/andar/#andar","title":"<code>andar</code>","text":""},{"location":"reference/andar/#andar.FieldConf","title":"<code>FieldConf</code>  <code>dataclass</code>","text":"<p>:param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using                 parse_path :param date_format: date_format and datetime_format are using for a second validation using parse_path,   for defining the how to cast the string (date or datetime, depending on the argument that was use)   and for get_path and get_parent_path of accepting either a string or a datetime object that can be   formated to input for a template string :param datetime_format: See description of date_format parameter. :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)                     or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must                     be constrained, otherwise the PathBuilder class may have an unexpected behaviour.                     For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True</p> Source code in <code>andar/path_builder.py</code> <pre><code>@dataclass\nclass FieldConf:\n    \"\"\"\n    :param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using\n                    parse_path\n    :param date_format: date_format and datetime_format are using for a second validation using parse_path,\n      for defining the how to cast the string (date or datetime, depending on the argument that was use)\n      and for get_path and get_parent_path of accepting either a string or a datetime object that can be\n      formated to input for a template string\n    :param datetime_format: See description of date_format parameter.\n    :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)\n                        or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must\n                        be constrained, otherwise the PathBuilder class may have an unexpected behaviour.\n                        For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True\n    \"\"\"\n\n    pattern: str = SafePatterns.FILENAME\n    date_format: str | None = None\n    datetime_format: str | None = None\n    is_optional: bool | None = False\n    str_to_var: Callable | None = None\n    var_to_str: Callable | None = None\n\n    def __post_init__(self):\n        has_date_converter = self.date_format is not None\n        has_datetime_converter = self.datetime_format is not None\n        has_custom_converter = self.var_to_str is not None or self.str_to_var is not None\n        active_converters_num = sum([has_date_converter, has_datetime_converter, has_custom_converter])\n        if active_converters_num &gt; 1:\n            raise ValueError(f\"Maximum one field converter is allowed, but {active_converters_num} were found\")\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced\n        :return: An FieldConf object with the attributes replaced\n        \"\"\"\n        field_conf = replace(self, **kwargs)\n        return field_conf\n</code></pre>"},{"location":"reference/andar/#andar.FieldConf.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced :return: An FieldConf object with the attributes replaced</p> Source code in <code>andar/path_builder.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced\n    :return: An FieldConf object with the attributes replaced\n    \"\"\"\n    field_conf = replace(self, **kwargs)\n    return field_conf\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder","title":"<code>PathBuilder</code>","text":"<p>Path Builder allows to define, create and parse templated paths</p> <p>It defines a path via a path template and its fields. Once instantiated, it allows to create new paths and to parse path strings to recover individual fields.</p> Source code in <code>andar/path_builder.py</code> <pre><code>class PathBuilder:\n    \"\"\"\n    Path Builder allows to define, create and parse templated paths\n\n    It defines a path via a path template and its fields. Once instantiated, it allows to create new paths\n    and to parse path strings to recover individual fields.\n\n    \"\"\"\n\n    template: str\n    fields: dict[str, FieldConf]\n    default_field: FieldConf\n    parent_template: str\n    _dir_sep: str = \"/\"\n\n    def __init__(\n        self,\n        template: str,\n        parent_template: str | None = None,\n        fields: dict[str, FieldConf] | None = None,\n        default_field: FieldConf | None = None,\n    ):\n        self.template = template\n\n        if parent_template is None:\n            parent_template = os.path.dirname(self.template)\n        self.check_parent_path_template(template, parent_template)\n        self.parent_template = parent_template\n\n        if default_field is None:\n            default_field = FieldConf()\n        self.default_field = default_field\n\n        new_fields = {}\n        template_field_names = self.get_template_fields_names(template)\n        for field_name in template_field_names:\n            new_fields[field_name] = default_field\n\n        if fields is not None:\n            new_fields.update(fields)\n        self.fields = new_fields\n\n        self.check_template_fields(template, new_fields)\n\n    def __repr__(self):\n        return f\"&lt;Template: '{self.template}', Fields: {self.fields}&gt;\"\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced, same arguments as used for PathBuilder instantiation\n        :return: A PathBuilder instance\n        \"\"\"\n        default_parent_template = None\n        if \"template\" not in kwargs:\n            kwargs[\"template\"] = self.template\n            default_parent_template = self.parent_template\n        if \"parent_template\" not in kwargs:\n            kwargs[\"parent_template\"] = default_parent_template\n        if \"fields\" not in kwargs:\n            kwargs[\"fields\"] = self.fields\n        if \"default_field\" not in kwargs:\n            kwargs[\"default_field\"] = self.default_field\n\n        return self.__class__(**kwargs)\n\n    def update(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object updating attributes with the given keyword arguments\n        :param kwargs: Attributes to be updated, same arguments as used for PathBuilder instantiation.\n                       Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                       be removed.\n        :return: A PathBuilder instance\n        \"\"\"\n        fields = self.fields.copy()\n        if \"fields\" in kwargs:\n            fields.update(kwargs[\"fields\"])\n            fields_names = list(fields.keys())\n            [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n            kwargs[\"fields\"] = fields\n        return self.replace(**kwargs)\n\n    def __call__(self, **kwargs) -&gt; Self:\n        if not kwargs:\n            return self\n        return self.replace(**kwargs)\n\n    @staticmethod\n    def get_template_fields_names(path_template: str) -&gt; list[str]:\n        \"\"\"\n        Get fields names from path template string\n\n        :param path_template: String. Path template that follows string.Formatter() syntax.\n        :return: List. Template fields names.\n        \"\"\"\n        parsed_field_tuples = list(string.Formatter().parse(path_template))\n        template_fields_names = [name for (text, name, spec, conv) in parsed_field_tuples if name is not None]\n        return template_fields_names\n\n    @classmethod\n    def check_template_fields(cls, path_template: str, map_dict: dict[str:Any]) -&gt; None:\n        \"\"\"\n        Check if fields in the path_template are coherent with keys in the given map_dict\n\n        :param path_template: String. Path template that follows string.Formatter() syntax.\n        :param map_dict: A dictionary where each key represent a field of the template and each value is string to be\n                         mapped\n        \"\"\"\n        template_fields = cls.get_template_fields_names(path_template)\n        invalid_fields = [f for f in map_dict if f not in template_fields]\n        if invalid_fields:\n            raise ValueError(f\"Invalid fields: {invalid_fields} they do not exist on path_template: '{path_template}'\")\n\n        missing_fields = [f for f in template_fields if f not in map_dict]\n        if missing_fields:\n            raise ValueError(f\"Missing fields: {missing_fields} they are required in path_template: '{path_template}'\")\n\n    @staticmethod\n    def assign_groupname_pattern_dict(pattern_dict: dict[str:str]) -&gt; dict[str:str]:\n        \"\"\"\n        Assign a group name to each regex pattern present in the given dictionary\n\n        :param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not\n                             check if the pattern already have a group name assign.\n        :return: A dictionary where the patterns have been assigned a group name.\n        \"\"\"\n        named_pattern_dict = {}\n        for field, pattern in pattern_dict.items():\n            named_pattern_dict[field] = f\"(?P&lt;{field}&gt;{pattern})\"\n        return named_pattern_dict\n\n    @classmethod\n    def parse_fields(\n        cls,\n        _string: str,\n        template: str,\n        pattern_dict: dict[str:str],\n        raise_error: bool = False,\n    ) -&gt; dict[str:str]:\n        \"\"\"\n        Parse a string using a template and a patterns dictionary\n\n        Example:\n        filename_template = \"{prefix}_{name}.{extension}\"\n        pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"}\n        filename = \"0001_example.json\"\n        parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict)\n        invalid_filename = \"invalid_example.json\"\n        parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)\n\n        :param _string: String to be parsed.\n        :param template: A template that follows string.Formatter() syntax.\n        :param pattern_dict: A dictionary where each key represent a field of the template and each value is the\n                             corresponding regex pattern\n        :param raise_error: Raise an exception if the path is not valid. If False, it returns None.\n        :return: A dictionary of parsed fields.\n        \"\"\"\n        cls.check_template_fields(template, pattern_dict)\n        template_fields = cls.get_template_fields_names(template)\n\n        # Deduplicate repeated fields of pattern_dict:\n        # for example the template \"/{base_path}/{asset_name}/{asset_name}_{suffix}\"\n        # will become \"/{base_path}/{asset_name__0}/{asset_name__1}_{suffix}\"\n        # and the dict {\"base_path\": r\"\\w+\", \"asset_name\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n        # will become {\"base_path\": r\"\\w+\", \"asset_name__0\": r\"\\w+\", \"asset_name__1\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n        unique_fields = list(set(template_fields))\n        deduplicated_fields_dict = {}\n        new_pattern_dict = {}\n        new_template = template\n        for field_name in unique_fields:\n            field_count = len([f for f in template_fields if f == field_name])\n            if field_count == 1:\n                new_pattern_dict[field_name] = pattern_dict[field_name]\n                continue\n            deduplicated_list = []\n            for idx in range(field_count):\n                new_field_name = field_name + f\"__{idx}\"\n                deduplicated_list.append(new_field_name)\n                new_pattern_dict[new_field_name] = pattern_dict[field_name]\n                new_template = new_template.replace(\"{\" + field_name + \"}\", \"{\" + new_field_name + \"}\", 1)\n            deduplicated_fields_dict[field_name] = deduplicated_list\n\n        has_duplicates = pattern_dict != new_pattern_dict\n        if has_duplicates:\n            pattern_dict = new_pattern_dict\n            template = new_template\n\n        # Build full pattern string\n        named_pattern_dict = cls.assign_groupname_pattern_dict(pattern_dict)\n        path_pattern = template.format(**named_pattern_dict)\n        path_pattern = f\"^{path_pattern}$\"  # match the full string\n        match = re.match(path_pattern, _string)\n        if not match:\n            if raise_error:\n                raise ValueError(f\"Invalid string '{_string}', expected pattern: '{path_pattern}'\")\n            return None\n        parsed_fields_dict = match.groupdict()\n\n        # Fusion deduplicated fields:\n        # it will raise an error if the deduplicate fields have multiples values\n        # for example this parsed dict will raise an error because asset_name__0 and asset_name__1 should be equal:\n        # {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"other_asset\", \"suffix\": \"001\"}\n        # if the deduplicated fields are coherent they will be fusion and renamed to its original name:\n        # for example {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"my_asset\", \"suffix\": \"001\"}\n        # to {\"base_path\": \"folder\", \"asset_name\": \"my_asset\", \"suffix\": \"001\"}\n        for original_field_name, deduplicated_list in deduplicated_fields_dict.items():\n            parsed_field_values = [parsed_fields_dict.pop(f) for f in deduplicated_list]\n            unique_parsed_field_values = list(set(parsed_field_values))\n            are_duplicated_unique = len(unique_parsed_field_values) == 1\n            if not are_duplicated_unique:\n                raise ValueError(\n                    f\"More than one value was found for repeated field '{original_field_name}': {parsed_field_values}\"\n                )\n            parsed_fields_dict[original_field_name] = unique_parsed_field_values[0]\n\n        return parsed_fields_dict\n\n    def parse_file_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n        \"\"\"\n        Parse a file path\n\n        :param file_path: String to be parsed.\n        :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n        :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n                 string (or converted object)\n        \"\"\"\n        ds = self._dir_sep\n        path_template = self.template\n        path_template = path_template.replace(r\".\", r\"\\.\")\n        pattern_dict = {}\n        for field_name, field_conf in self.fields.items():\n            field_pattern = field_conf.pattern\n            if field_conf.is_optional:\n                field_pattern = f\"{field_pattern}|\"\n                # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n                field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n                optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n                path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n            pattern_dict[field_name] = field_pattern\n        parsed_fields = self.parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n        processed_fields = self.process_parsed_fields_values(parsed_fields)\n        return processed_fields\n\n    @classmethod\n    def check_parent_path_template(cls, path_template: str, parent_path_template: str) -&gt; None:\n        \"\"\"\n        Check if parent_path_template is coherent with path_template\n\n        :param path_template: String. Path template that follows string.Formatter() syntax.\n        :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.\n        \"\"\"\n        if parent_path_template not in path_template:\n            raise ValueError(\n                f\"path_template: '{path_template}' does not match with parent_path_template: \"\n                f\"'{parent_path_template}'. parent_path_template must be a substring of path_template\"\n            )\n\n    @classmethod\n    def prepare_fields_values(\n        cls, fields_values_dict: dict[str:Any], fields_conf: dict[str, FieldConf]\n    ) -&gt; dict[str:str]:\n        \"\"\"\n        Prepare fields values for this path\n        :param fields_values_dict: Dictionary of fields values\n        :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf)\n        :return: A dictionary of fields where the values were converted to strings.\n        \"\"\"\n        new_fields_values_dict = {}\n        for field_name, field_value in fields_values_dict.items():\n            if field_name not in fields_conf:\n                print(f\"skipping field '{field_name}'\")\n                continue\n            field_conf = fields_conf[field_name]\n\n            if field_value is None and field_conf.is_optional:\n                new_fields_values_dict[field_name] = \"\"\n                continue\n\n            if field_conf.date_format is not None:\n                new_field_value = field_value.strftime(field_conf.date_format)\n            elif field_conf.datetime_format is not None:\n                new_field_value = field_value.strftime(field_conf.datetime_format)\n            elif field_conf.var_to_str is not None:\n                new_field_value = field_conf.var_to_str(field_value)\n            else:\n                new_field_value = str(field_value)\n\n            field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n            result = re.match(field_pattern, new_field_value)\n            if result is None:\n                raise ValueError(\n                    f\"Invalid field '{field_name}' value: '{new_field_value}'. It does not match pattern: \"\n                    f\"'{field_conf.pattern}'\"\n                )\n            new_fields_values_dict[field_name] = new_field_value\n        return new_fields_values_dict\n\n    def process_parsed_fields_values(self, parsed_fields: dict[str:str]) -&gt; dict[str:Any]:\n        \"\"\"\n        Process fields values dictionary obtained from parsing a file path\n        :param parsed_fields: A dictionary of parsed fields values in string format.\n        :return: A processed dictionary of fields with converted values depending on each FieldConf definition.\n        \"\"\"\n        new_parsed_fields = parsed_fields.copy()\n\n        for field_name, field_value in new_parsed_fields.items():\n            if field_name not in self.fields:\n                raise ValueError(f\"Unknown field '{field_name}'. Valid fields are: {self.fields.keys()}\")\n            field_conf = self.fields[field_name]\n\n            field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n            if field_conf.is_optional:\n                field_pattern = f\"^{field_conf.pattern}|$\"\n            result = re.match(field_pattern, field_value)\n            if result is None:\n                raise ValueError(\n                    f\"Invalid field '{field_name}' value: '{field_value}'. It does not match pattern: \"\n                    f\"'{field_conf.pattern}'\"\n                )\n\n            if field_conf.date_format is not None:\n                new_field_value = dt.datetime.strptime(field_value, field_conf.date_format).date()\n            elif field_conf.datetime_format is not None:\n                new_field_value = dt.datetime.strptime(field_value, field_conf.datetime_format)\n            elif field_conf.str_to_var is not None:\n                new_field_value = field_conf.str_to_var(field_value)\n            else:\n                new_field_value = str(field_value)\n\n            if new_field_value == \"\" and field_conf.is_optional:\n                new_field_value = None\n\n            new_parsed_fields[field_name] = new_field_value\n        return new_parsed_fields\n\n    @classmethod\n    def _get_path(\n        cls,\n        template: str,\n        fields_conf: dict[str, FieldConf],\n        fields_values_dict: dict[str, Any],\n    ) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param template: A template that follows string.Formatter() syntax.\n        :param fields_conf: Dictionary of fields configurations, where keys are field names and values are FieldConf\n                            instances.\n        :param fields_values_dict: Input parameters dict that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        fields_values_dict = fields_values_dict.copy()\n        template_fields = cls.get_template_fields_names(template)\n        missing_fields = [field for field in template_fields if field not in fields_values_dict]\n\n        for field_name in missing_fields:\n            is_optional = fields_conf[field_name].is_optional\n            if is_optional:\n                fields_values_dict[field_name] = None\n\n        cls.check_template_fields(template, fields_values_dict)\n        fields_values_dict = cls.prepare_fields_values(fields_values_dict, fields_conf)\n        new_path = template.format(**fields_values_dict)\n        new_path = os.path.normpath(new_path)\n        return new_path\n\n    def get_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n\n    def get_parent_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate parent path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                       parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                       updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                       an error will be raised.\n        :return: String. Parent path.\n        \"\"\"\n\n        # remove all fields not present in parent template\n        parent_fields = self.fields.copy()\n        fields_names = self.get_template_fields_names(self.template)\n        parent_fields_names = self.get_template_fields_names(self.parent_template)\n\n        # Drop fields corresponding to filename\n        for field in fields_names:\n            if field not in parent_fields_names:\n                parent_fields.pop(field)\n\n        # Make dynamic the parent path creation, so the last fields can be omitted\n        # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n        new_parent_template = self.parent_template\n        dynamic_fields_names = []\n        missing_kwarg_name = None\n        for parent_field_name in parent_fields_names:\n            is_optional = parent_fields[parent_field_name].is_optional\n            if parent_field_name not in kwargs and not is_optional:\n                # keep known (left) part of parent_template and drop the rest\n                missing_kwarg_name = parent_field_name\n                new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n                break\n            dynamic_fields_names.append(parent_field_name)\n\n        # Drop fields corresponding to last arguments that were skipped\n        parent_fields_names = list(parent_fields.keys())\n        for field_name in parent_fields_names:\n            if field_name not in dynamic_fields_names:\n                parent_fields.pop(field_name)\n\n        # Check for unnecessary extra args\n        extra_kwargs = {}\n        for field_name in kwargs:\n            if field_name not in parent_fields:\n                extra_kwargs[field_name] = kwargs[field_name]\n        if missing_kwarg_name and extra_kwargs:\n            raise ValueError(\n                f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n                f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n            )\n\n        return self._get_path(\n            template=new_parent_template,\n            fields_conf=parent_fields,\n            fields_values_dict=kwargs,\n        )\n\n    def assert_path_bijection(self, test_path: str):\n        \"\"\"\n        Assert path bijection\n\n        It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n        :param test_path: Path string to be tested\n        \"\"\"\n        parsed_fields = self.parse_file_path(test_path, raise_error=True)\n        result_test_path = self.get_path(**parsed_fields)\n        assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n\n    def assert_fields_bijection(self, test_fields: dict[str, Any]):\n        \"\"\"\n        Assert fields bijection\n\n        It tries to recover the same initial input after processing once with get_path and parse_file_path\n        This method is the preferred way of checking if the PathBuilder was well-defined.\n\n        :param test_fields: Dictionary of fields to be tested\n        \"\"\"\n        test_path = self.get_path(**test_fields)\n        result_parsed_fields = self.parse_file_path(test_path, raise_error=True)\n        assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.assert_fields_bijection","title":"<code>assert_fields_bijection(test_fields)</code>","text":"<p>Assert fields bijection</p> <p>It tries to recover the same initial input after processing once with get_path and parse_file_path This method is the preferred way of checking if the PathBuilder was well-defined.</p> <p>:param test_fields: Dictionary of fields to be tested</p> Source code in <code>andar/path_builder.py</code> <pre><code>def assert_fields_bijection(self, test_fields: dict[str, Any]):\n    \"\"\"\n    Assert fields bijection\n\n    It tries to recover the same initial input after processing once with get_path and parse_file_path\n    This method is the preferred way of checking if the PathBuilder was well-defined.\n\n    :param test_fields: Dictionary of fields to be tested\n    \"\"\"\n    test_path = self.get_path(**test_fields)\n    result_parsed_fields = self.parse_file_path(test_path, raise_error=True)\n    assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.assert_path_bijection","title":"<code>assert_path_bijection(test_path)</code>","text":"<p>Assert path bijection</p> <p>It tries to recover the same initial input after processing once with parse_file_path and get_path</p> <p>:param test_path: Path string to be tested</p> Source code in <code>andar/path_builder.py</code> <pre><code>def assert_path_bijection(self, test_path: str):\n    \"\"\"\n    Assert path bijection\n\n    It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n    :param test_path: Path string to be tested\n    \"\"\"\n    parsed_fields = self.parse_file_path(test_path, raise_error=True)\n    result_test_path = self.get_path(**parsed_fields)\n    assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.assign_groupname_pattern_dict","title":"<code>assign_groupname_pattern_dict(pattern_dict)</code>  <code>staticmethod</code>","text":"<p>Assign a group name to each regex pattern present in the given dictionary</p> <p>:param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not                      check if the pattern already have a group name assign. :return: A dictionary where the patterns have been assigned a group name.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@staticmethod\ndef assign_groupname_pattern_dict(pattern_dict: dict[str:str]) -&gt; dict[str:str]:\n    \"\"\"\n    Assign a group name to each regex pattern present in the given dictionary\n\n    :param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not\n                         check if the pattern already have a group name assign.\n    :return: A dictionary where the patterns have been assigned a group name.\n    \"\"\"\n    named_pattern_dict = {}\n    for field, pattern in pattern_dict.items():\n        named_pattern_dict[field] = f\"(?P&lt;{field}&gt;{pattern})\"\n    return named_pattern_dict\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.check_parent_path_template","title":"<code>check_parent_path_template(path_template, parent_path_template)</code>  <code>classmethod</code>","text":"<p>Check if parent_path_template is coherent with path_template</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@classmethod\ndef check_parent_path_template(cls, path_template: str, parent_path_template: str) -&gt; None:\n    \"\"\"\n    Check if parent_path_template is coherent with path_template\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.\n    \"\"\"\n    if parent_path_template not in path_template:\n        raise ValueError(\n            f\"path_template: '{path_template}' does not match with parent_path_template: \"\n            f\"'{parent_path_template}'. parent_path_template must be a substring of path_template\"\n        )\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.check_template_fields","title":"<code>check_template_fields(path_template, map_dict)</code>  <code>classmethod</code>","text":"<p>Check if fields in the path_template are coherent with keys in the given map_dict</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :param map_dict: A dictionary where each key represent a field of the template and each value is string to be                  mapped</p> Source code in <code>andar/path_builder.py</code> <pre><code>@classmethod\ndef check_template_fields(cls, path_template: str, map_dict: dict[str:Any]) -&gt; None:\n    \"\"\"\n    Check if fields in the path_template are coherent with keys in the given map_dict\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :param map_dict: A dictionary where each key represent a field of the template and each value is string to be\n                     mapped\n    \"\"\"\n    template_fields = cls.get_template_fields_names(path_template)\n    invalid_fields = [f for f in map_dict if f not in template_fields]\n    if invalid_fields:\n        raise ValueError(f\"Invalid fields: {invalid_fields} they do not exist on path_template: '{path_template}'\")\n\n    missing_fields = [f for f in template_fields if f not in map_dict]\n    if missing_fields:\n        raise ValueError(f\"Missing fields: {missing_fields} they are required in path_template: '{path_template}'\")\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.get_parent_path","title":"<code>get_parent_path(**kwargs)</code>","text":"<p>Generate parent path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. They are used in the order of                parent_template, if the last argument(s) are omitted, the parent_template will be dynamically                updated to a shorter version. If an argument in the middle is omitted, and it is not optional,                an error will be raised. :return: String. Parent path.</p> Source code in <code>andar/path_builder.py</code> <pre><code>def get_parent_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate parent path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                   parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                   updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                   an error will be raised.\n    :return: String. Parent path.\n    \"\"\"\n\n    # remove all fields not present in parent template\n    parent_fields = self.fields.copy()\n    fields_names = self.get_template_fields_names(self.template)\n    parent_fields_names = self.get_template_fields_names(self.parent_template)\n\n    # Drop fields corresponding to filename\n    for field in fields_names:\n        if field not in parent_fields_names:\n            parent_fields.pop(field)\n\n    # Make dynamic the parent path creation, so the last fields can be omitted\n    # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n    new_parent_template = self.parent_template\n    dynamic_fields_names = []\n    missing_kwarg_name = None\n    for parent_field_name in parent_fields_names:\n        is_optional = parent_fields[parent_field_name].is_optional\n        if parent_field_name not in kwargs and not is_optional:\n            # keep known (left) part of parent_template and drop the rest\n            missing_kwarg_name = parent_field_name\n            new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n            break\n        dynamic_fields_names.append(parent_field_name)\n\n    # Drop fields corresponding to last arguments that were skipped\n    parent_fields_names = list(parent_fields.keys())\n    for field_name in parent_fields_names:\n        if field_name not in dynamic_fields_names:\n            parent_fields.pop(field_name)\n\n    # Check for unnecessary extra args\n    extra_kwargs = {}\n    for field_name in kwargs:\n        if field_name not in parent_fields:\n            extra_kwargs[field_name] = kwargs[field_name]\n    if missing_kwarg_name and extra_kwargs:\n        raise ValueError(\n            f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n            f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n        )\n\n    return self._get_path(\n        template=new_parent_template,\n        fields_conf=parent_fields,\n        fields_values_dict=kwargs,\n    )\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.get_path","title":"<code>get_path(**kwargs)</code>","text":"<p>Generate path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. :return: String. Path.</p> Source code in <code>andar/path_builder.py</code> <pre><code>def get_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values.\n    :return: String. Path.\n    \"\"\"\n    return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.get_template_fields_names","title":"<code>get_template_fields_names(path_template)</code>  <code>staticmethod</code>","text":"<p>Get fields names from path template string</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :return: List. Template fields names.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@staticmethod\ndef get_template_fields_names(path_template: str) -&gt; list[str]:\n    \"\"\"\n    Get fields names from path template string\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :return: List. Template fields names.\n    \"\"\"\n    parsed_field_tuples = list(string.Formatter().parse(path_template))\n    template_fields_names = [name for (text, name, spec, conv) in parsed_field_tuples if name is not None]\n    return template_fields_names\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.parse_fields","title":"<code>parse_fields(_string, template, pattern_dict, raise_error=False)</code>  <code>classmethod</code>","text":"<p>Parse a string using a template and a patterns dictionary</p> <p>Example: filename_template = \"{prefix}_{name}.{extension}\" pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"} filename = \"0001_example.json\" parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict) invalid_filename = \"invalid_example.json\" parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)</p> <p>:param _string: String to be parsed. :param template: A template that follows string.Formatter() syntax. :param pattern_dict: A dictionary where each key represent a field of the template and each value is the                      corresponding regex pattern :param raise_error: Raise an exception if the path is not valid. If False, it returns None. :return: A dictionary of parsed fields.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@classmethod\ndef parse_fields(\n    cls,\n    _string: str,\n    template: str,\n    pattern_dict: dict[str:str],\n    raise_error: bool = False,\n) -&gt; dict[str:str]:\n    \"\"\"\n    Parse a string using a template and a patterns dictionary\n\n    Example:\n    filename_template = \"{prefix}_{name}.{extension}\"\n    pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"}\n    filename = \"0001_example.json\"\n    parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict)\n    invalid_filename = \"invalid_example.json\"\n    parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)\n\n    :param _string: String to be parsed.\n    :param template: A template that follows string.Formatter() syntax.\n    :param pattern_dict: A dictionary where each key represent a field of the template and each value is the\n                         corresponding regex pattern\n    :param raise_error: Raise an exception if the path is not valid. If False, it returns None.\n    :return: A dictionary of parsed fields.\n    \"\"\"\n    cls.check_template_fields(template, pattern_dict)\n    template_fields = cls.get_template_fields_names(template)\n\n    # Deduplicate repeated fields of pattern_dict:\n    # for example the template \"/{base_path}/{asset_name}/{asset_name}_{suffix}\"\n    # will become \"/{base_path}/{asset_name__0}/{asset_name__1}_{suffix}\"\n    # and the dict {\"base_path\": r\"\\w+\", \"asset_name\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    # will become {\"base_path\": r\"\\w+\", \"asset_name__0\": r\"\\w+\", \"asset_name__1\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    unique_fields = list(set(template_fields))\n    deduplicated_fields_dict = {}\n    new_pattern_dict = {}\n    new_template = template\n    for field_name in unique_fields:\n        field_count = len([f for f in template_fields if f == field_name])\n        if field_count == 1:\n            new_pattern_dict[field_name] = pattern_dict[field_name]\n            continue\n        deduplicated_list = []\n        for idx in range(field_count):\n            new_field_name = field_name + f\"__{idx}\"\n            deduplicated_list.append(new_field_name)\n            new_pattern_dict[new_field_name] = pattern_dict[field_name]\n            new_template = new_template.replace(\"{\" + field_name + \"}\", \"{\" + new_field_name + \"}\", 1)\n        deduplicated_fields_dict[field_name] = deduplicated_list\n\n    has_duplicates = pattern_dict != new_pattern_dict\n    if has_duplicates:\n        pattern_dict = new_pattern_dict\n        template = new_template\n\n    # Build full pattern string\n    named_pattern_dict = cls.assign_groupname_pattern_dict(pattern_dict)\n    path_pattern = template.format(**named_pattern_dict)\n    path_pattern = f\"^{path_pattern}$\"  # match the full string\n    match = re.match(path_pattern, _string)\n    if not match:\n        if raise_error:\n            raise ValueError(f\"Invalid string '{_string}', expected pattern: '{path_pattern}'\")\n        return None\n    parsed_fields_dict = match.groupdict()\n\n    # Fusion deduplicated fields:\n    # it will raise an error if the deduplicate fields have multiples values\n    # for example this parsed dict will raise an error because asset_name__0 and asset_name__1 should be equal:\n    # {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"other_asset\", \"suffix\": \"001\"}\n    # if the deduplicated fields are coherent they will be fusion and renamed to its original name:\n    # for example {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"my_asset\", \"suffix\": \"001\"}\n    # to {\"base_path\": \"folder\", \"asset_name\": \"my_asset\", \"suffix\": \"001\"}\n    for original_field_name, deduplicated_list in deduplicated_fields_dict.items():\n        parsed_field_values = [parsed_fields_dict.pop(f) for f in deduplicated_list]\n        unique_parsed_field_values = list(set(parsed_field_values))\n        are_duplicated_unique = len(unique_parsed_field_values) == 1\n        if not are_duplicated_unique:\n            raise ValueError(\n                f\"More than one value was found for repeated field '{original_field_name}': {parsed_field_values}\"\n            )\n        parsed_fields_dict[original_field_name] = unique_parsed_field_values[0]\n\n    return parsed_fields_dict\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.parse_file_path","title":"<code>parse_file_path(file_path, raise_error=False)</code>","text":"<p>Parse a file path</p> <p>:param file_path: String to be parsed. :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None. :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed          string (or converted object)</p> Source code in <code>andar/path_builder.py</code> <pre><code>def parse_file_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n    \"\"\"\n    Parse a file path\n\n    :param file_path: String to be parsed.\n    :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n    :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n             string (or converted object)\n    \"\"\"\n    ds = self._dir_sep\n    path_template = self.template\n    path_template = path_template.replace(r\".\", r\"\\.\")\n    pattern_dict = {}\n    for field_name, field_conf in self.fields.items():\n        field_pattern = field_conf.pattern\n        if field_conf.is_optional:\n            field_pattern = f\"{field_pattern}|\"\n            # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n            field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n            optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n            path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n        pattern_dict[field_name] = field_pattern\n    parsed_fields = self.parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n    processed_fields = self.process_parsed_fields_values(parsed_fields)\n    return processed_fields\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.prepare_fields_values","title":"<code>prepare_fields_values(fields_values_dict, fields_conf)</code>  <code>classmethod</code>","text":"<p>Prepare fields values for this path :param fields_values_dict: Dictionary of fields values :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf) :return: A dictionary of fields where the values were converted to strings.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@classmethod\ndef prepare_fields_values(\n    cls, fields_values_dict: dict[str:Any], fields_conf: dict[str, FieldConf]\n) -&gt; dict[str:str]:\n    \"\"\"\n    Prepare fields values for this path\n    :param fields_values_dict: Dictionary of fields values\n    :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf)\n    :return: A dictionary of fields where the values were converted to strings.\n    \"\"\"\n    new_fields_values_dict = {}\n    for field_name, field_value in fields_values_dict.items():\n        if field_name not in fields_conf:\n            print(f\"skipping field '{field_name}'\")\n            continue\n        field_conf = fields_conf[field_name]\n\n        if field_value is None and field_conf.is_optional:\n            new_fields_values_dict[field_name] = \"\"\n            continue\n\n        if field_conf.date_format is not None:\n            new_field_value = field_value.strftime(field_conf.date_format)\n        elif field_conf.datetime_format is not None:\n            new_field_value = field_value.strftime(field_conf.datetime_format)\n        elif field_conf.var_to_str is not None:\n            new_field_value = field_conf.var_to_str(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        result = re.match(field_pattern, new_field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{new_field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n        new_fields_values_dict[field_name] = new_field_value\n    return new_fields_values_dict\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.process_parsed_fields_values","title":"<code>process_parsed_fields_values(parsed_fields)</code>","text":"<p>Process fields values dictionary obtained from parsing a file path :param parsed_fields: A dictionary of parsed fields values in string format. :return: A processed dictionary of fields with converted values depending on each FieldConf definition.</p> Source code in <code>andar/path_builder.py</code> <pre><code>def process_parsed_fields_values(self, parsed_fields: dict[str:str]) -&gt; dict[str:Any]:\n    \"\"\"\n    Process fields values dictionary obtained from parsing a file path\n    :param parsed_fields: A dictionary of parsed fields values in string format.\n    :return: A processed dictionary of fields with converted values depending on each FieldConf definition.\n    \"\"\"\n    new_parsed_fields = parsed_fields.copy()\n\n    for field_name, field_value in new_parsed_fields.items():\n        if field_name not in self.fields:\n            raise ValueError(f\"Unknown field '{field_name}'. Valid fields are: {self.fields.keys()}\")\n        field_conf = self.fields[field_name]\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        if field_conf.is_optional:\n            field_pattern = f\"^{field_conf.pattern}|$\"\n        result = re.match(field_pattern, field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n\n        if field_conf.date_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.date_format).date()\n        elif field_conf.datetime_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.datetime_format)\n        elif field_conf.str_to_var is not None:\n            new_field_value = field_conf.str_to_var(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        if new_field_value == \"\" and field_conf.is_optional:\n            new_field_value = None\n\n        new_parsed_fields[field_name] = new_field_value\n    return new_parsed_fields\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced, same arguments as used for PathBuilder instantiation :return: A PathBuilder instance</p> Source code in <code>andar/path_builder.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced, same arguments as used for PathBuilder instantiation\n    :return: A PathBuilder instance\n    \"\"\"\n    default_parent_template = None\n    if \"template\" not in kwargs:\n        kwargs[\"template\"] = self.template\n        default_parent_template = self.parent_template\n    if \"parent_template\" not in kwargs:\n        kwargs[\"parent_template\"] = default_parent_template\n    if \"fields\" not in kwargs:\n        kwargs[\"fields\"] = self.fields\n    if \"default_field\" not in kwargs:\n        kwargs[\"default_field\"] = self.default_field\n\n    return self.__class__(**kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.PathBuilder.update","title":"<code>update(**kwargs)</code>","text":"<p>Creates a copy of the current object updating attributes with the given keyword arguments :param kwargs: Attributes to be updated, same arguments as used for PathBuilder instantiation.                Fields set to None, will be reset to default, if it is no longer present on the template, it will                be removed. :return: A PathBuilder instance</p> Source code in <code>andar/path_builder.py</code> <pre><code>def update(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object updating attributes with the given keyword arguments\n    :param kwargs: Attributes to be updated, same arguments as used for PathBuilder instantiation.\n                   Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                   be removed.\n    :return: A PathBuilder instance\n    \"\"\"\n    fields = self.fields.copy()\n    if \"fields\" in kwargs:\n        fields.update(kwargs[\"fields\"])\n        fields_names = list(fields.keys())\n        [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n        kwargs[\"fields\"] = fields\n    return self.replace(**kwargs)\n</code></pre>"},{"location":"reference/andar/#andar.SafePatterns","title":"<code>SafePatterns</code>","text":"<p>Non-greedy patterns</p> Source code in <code>andar/path_builder.py</code> <pre><code>class SafePatterns:\n    \"\"\"\n    Non-greedy patterns\n    \"\"\"\n\n    FILENAME = r\"[-_.a-zA-Z0-9]+?\"  # include filename separators: -_.\n    DIRPATH = r\"[-_.a-zA-Z0-9/]+?\"  # include filename separators: -_. and directory separator: /\n    FIELD = r\"[a-zA-Z0-9]+?\"  # without separator characters\n    EXTENSION = r\"[.a-zA-Z0-9]+?\"  # include dots for sub extensions as 'tar.gz'\n</code></pre>"},{"location":"reference/andar/path_builder/","title":"path_builder","text":""},{"location":"reference/andar/path_builder/#andar.path_builder","title":"<code>andar.path_builder</code>","text":""},{"location":"reference/andar/path_builder/#andar.path_builder.FieldConf","title":"<code>FieldConf</code>  <code>dataclass</code>","text":"<p>:param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using                 parse_path :param date_format: date_format and datetime_format are using for a second validation using parse_path,   for defining the how to cast the string (date or datetime, depending on the argument that was use)   and for get_path and get_parent_path of accepting either a string or a datetime object that can be   formated to input for a template string :param datetime_format: See description of date_format parameter. :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)                     or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must                     be constrained, otherwise the PathBuilder class may have an unexpected behaviour.                     For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True</p> Source code in <code>andar/path_builder.py</code> <pre><code>@dataclass\nclass FieldConf:\n    \"\"\"\n    :param pattern: is used for validate input of get_path and get_parent_path, and also for getting fields using\n                    parse_path\n    :param date_format: date_format and datetime_format are using for a second validation using parse_path,\n      for defining the how to cast the string (date or datetime, depending on the argument that was use)\n      and for get_path and get_parent_path of accepting either a string or a datetime object that can be\n      formated to input for a template string\n    :param datetime_format: See description of date_format parameter.\n    :param is_optional: allows to omit a field during the path generation (get_path and get_parent_path)\n                        or to skip field during the path parsing. IMPORTANT! in order to work properly, pattern must\n                        be constrained, otherwise the PathBuilder class may have an unexpected behaviour.\n                        For example use '[0-9]{4}' and avoid using '*' or '+' when using is_optional=True\n    \"\"\"\n\n    pattern: str = SafePatterns.FILENAME\n    date_format: str | None = None\n    datetime_format: str | None = None\n    is_optional: bool | None = False\n    str_to_var: Callable | None = None\n    var_to_str: Callable | None = None\n\n    def __post_init__(self):\n        has_date_converter = self.date_format is not None\n        has_datetime_converter = self.datetime_format is not None\n        has_custom_converter = self.var_to_str is not None or self.str_to_var is not None\n        active_converters_num = sum([has_date_converter, has_datetime_converter, has_custom_converter])\n        if active_converters_num &gt; 1:\n            raise ValueError(f\"Maximum one field converter is allowed, but {active_converters_num} were found\")\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced\n        :return: An FieldConf object with the attributes replaced\n        \"\"\"\n        field_conf = replace(self, **kwargs)\n        return field_conf\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.FieldConf.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced :return: An FieldConf object with the attributes replaced</p> Source code in <code>andar/path_builder.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced\n    :return: An FieldConf object with the attributes replaced\n    \"\"\"\n    field_conf = replace(self, **kwargs)\n    return field_conf\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder","title":"<code>PathBuilder</code>","text":"<p>Path Builder allows to define, create and parse templated paths</p> <p>It defines a path via a path template and its fields. Once instantiated, it allows to create new paths and to parse path strings to recover individual fields.</p> Source code in <code>andar/path_builder.py</code> <pre><code>class PathBuilder:\n    \"\"\"\n    Path Builder allows to define, create and parse templated paths\n\n    It defines a path via a path template and its fields. Once instantiated, it allows to create new paths\n    and to parse path strings to recover individual fields.\n\n    \"\"\"\n\n    template: str\n    fields: dict[str, FieldConf]\n    default_field: FieldConf\n    parent_template: str\n    _dir_sep: str = \"/\"\n\n    def __init__(\n        self,\n        template: str,\n        parent_template: str | None = None,\n        fields: dict[str, FieldConf] | None = None,\n        default_field: FieldConf | None = None,\n    ):\n        self.template = template\n\n        if parent_template is None:\n            parent_template = os.path.dirname(self.template)\n        self.check_parent_path_template(template, parent_template)\n        self.parent_template = parent_template\n\n        if default_field is None:\n            default_field = FieldConf()\n        self.default_field = default_field\n\n        new_fields = {}\n        template_field_names = self.get_template_fields_names(template)\n        for field_name in template_field_names:\n            new_fields[field_name] = default_field\n\n        if fields is not None:\n            new_fields.update(fields)\n        self.fields = new_fields\n\n        self.check_template_fields(template, new_fields)\n\n    def __repr__(self):\n        return f\"&lt;Template: '{self.template}', Fields: {self.fields}&gt;\"\n\n    def replace(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object replacing attributes with the given keyword arguments\n\n        :param kwargs: Attributes to be replaced, same arguments as used for PathBuilder instantiation\n        :return: A PathBuilder instance\n        \"\"\"\n        default_parent_template = None\n        if \"template\" not in kwargs:\n            kwargs[\"template\"] = self.template\n            default_parent_template = self.parent_template\n        if \"parent_template\" not in kwargs:\n            kwargs[\"parent_template\"] = default_parent_template\n        if \"fields\" not in kwargs:\n            kwargs[\"fields\"] = self.fields\n        if \"default_field\" not in kwargs:\n            kwargs[\"default_field\"] = self.default_field\n\n        return self.__class__(**kwargs)\n\n    def update(self, **kwargs) -&gt; Self:\n        \"\"\"\n        Creates a copy of the current object updating attributes with the given keyword arguments\n        :param kwargs: Attributes to be updated, same arguments as used for PathBuilder instantiation.\n                       Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                       be removed.\n        :return: A PathBuilder instance\n        \"\"\"\n        fields = self.fields.copy()\n        if \"fields\" in kwargs:\n            fields.update(kwargs[\"fields\"])\n            fields_names = list(fields.keys())\n            [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n            kwargs[\"fields\"] = fields\n        return self.replace(**kwargs)\n\n    def __call__(self, **kwargs) -&gt; Self:\n        if not kwargs:\n            return self\n        return self.replace(**kwargs)\n\n    @staticmethod\n    def get_template_fields_names(path_template: str) -&gt; list[str]:\n        \"\"\"\n        Get fields names from path template string\n\n        :param path_template: String. Path template that follows string.Formatter() syntax.\n        :return: List. Template fields names.\n        \"\"\"\n        parsed_field_tuples = list(string.Formatter().parse(path_template))\n        template_fields_names = [name for (text, name, spec, conv) in parsed_field_tuples if name is not None]\n        return template_fields_names\n\n    @classmethod\n    def check_template_fields(cls, path_template: str, map_dict: dict[str:Any]) -&gt; None:\n        \"\"\"\n        Check if fields in the path_template are coherent with keys in the given map_dict\n\n        :param path_template: String. Path template that follows string.Formatter() syntax.\n        :param map_dict: A dictionary where each key represent a field of the template and each value is string to be\n                         mapped\n        \"\"\"\n        template_fields = cls.get_template_fields_names(path_template)\n        invalid_fields = [f for f in map_dict if f not in template_fields]\n        if invalid_fields:\n            raise ValueError(f\"Invalid fields: {invalid_fields} they do not exist on path_template: '{path_template}'\")\n\n        missing_fields = [f for f in template_fields if f not in map_dict]\n        if missing_fields:\n            raise ValueError(f\"Missing fields: {missing_fields} they are required in path_template: '{path_template}'\")\n\n    @staticmethod\n    def assign_groupname_pattern_dict(pattern_dict: dict[str:str]) -&gt; dict[str:str]:\n        \"\"\"\n        Assign a group name to each regex pattern present in the given dictionary\n\n        :param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not\n                             check if the pattern already have a group name assign.\n        :return: A dictionary where the patterns have been assigned a group name.\n        \"\"\"\n        named_pattern_dict = {}\n        for field, pattern in pattern_dict.items():\n            named_pattern_dict[field] = f\"(?P&lt;{field}&gt;{pattern})\"\n        return named_pattern_dict\n\n    @classmethod\n    def parse_fields(\n        cls,\n        _string: str,\n        template: str,\n        pattern_dict: dict[str:str],\n        raise_error: bool = False,\n    ) -&gt; dict[str:str]:\n        \"\"\"\n        Parse a string using a template and a patterns dictionary\n\n        Example:\n        filename_template = \"{prefix}_{name}.{extension}\"\n        pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"}\n        filename = \"0001_example.json\"\n        parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict)\n        invalid_filename = \"invalid_example.json\"\n        parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)\n\n        :param _string: String to be parsed.\n        :param template: A template that follows string.Formatter() syntax.\n        :param pattern_dict: A dictionary where each key represent a field of the template and each value is the\n                             corresponding regex pattern\n        :param raise_error: Raise an exception if the path is not valid. If False, it returns None.\n        :return: A dictionary of parsed fields.\n        \"\"\"\n        cls.check_template_fields(template, pattern_dict)\n        template_fields = cls.get_template_fields_names(template)\n\n        # Deduplicate repeated fields of pattern_dict:\n        # for example the template \"/{base_path}/{asset_name}/{asset_name}_{suffix}\"\n        # will become \"/{base_path}/{asset_name__0}/{asset_name__1}_{suffix}\"\n        # and the dict {\"base_path\": r\"\\w+\", \"asset_name\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n        # will become {\"base_path\": r\"\\w+\", \"asset_name__0\": r\"\\w+\", \"asset_name__1\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n        unique_fields = list(set(template_fields))\n        deduplicated_fields_dict = {}\n        new_pattern_dict = {}\n        new_template = template\n        for field_name in unique_fields:\n            field_count = len([f for f in template_fields if f == field_name])\n            if field_count == 1:\n                new_pattern_dict[field_name] = pattern_dict[field_name]\n                continue\n            deduplicated_list = []\n            for idx in range(field_count):\n                new_field_name = field_name + f\"__{idx}\"\n                deduplicated_list.append(new_field_name)\n                new_pattern_dict[new_field_name] = pattern_dict[field_name]\n                new_template = new_template.replace(\"{\" + field_name + \"}\", \"{\" + new_field_name + \"}\", 1)\n            deduplicated_fields_dict[field_name] = deduplicated_list\n\n        has_duplicates = pattern_dict != new_pattern_dict\n        if has_duplicates:\n            pattern_dict = new_pattern_dict\n            template = new_template\n\n        # Build full pattern string\n        named_pattern_dict = cls.assign_groupname_pattern_dict(pattern_dict)\n        path_pattern = template.format(**named_pattern_dict)\n        path_pattern = f\"^{path_pattern}$\"  # match the full string\n        match = re.match(path_pattern, _string)\n        if not match:\n            if raise_error:\n                raise ValueError(f\"Invalid string '{_string}', expected pattern: '{path_pattern}'\")\n            return None\n        parsed_fields_dict = match.groupdict()\n\n        # Fusion deduplicated fields:\n        # it will raise an error if the deduplicate fields have multiples values\n        # for example this parsed dict will raise an error because asset_name__0 and asset_name__1 should be equal:\n        # {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"other_asset\", \"suffix\": \"001\"}\n        # if the deduplicated fields are coherent they will be fusion and renamed to its original name:\n        # for example {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"my_asset\", \"suffix\": \"001\"}\n        # to {\"base_path\": \"folder\", \"asset_name\": \"my_asset\", \"suffix\": \"001\"}\n        for original_field_name, deduplicated_list in deduplicated_fields_dict.items():\n            parsed_field_values = [parsed_fields_dict.pop(f) for f in deduplicated_list]\n            unique_parsed_field_values = list(set(parsed_field_values))\n            are_duplicated_unique = len(unique_parsed_field_values) == 1\n            if not are_duplicated_unique:\n                raise ValueError(\n                    f\"More than one value was found for repeated field '{original_field_name}': {parsed_field_values}\"\n                )\n            parsed_fields_dict[original_field_name] = unique_parsed_field_values[0]\n\n        return parsed_fields_dict\n\n    def parse_file_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n        \"\"\"\n        Parse a file path\n\n        :param file_path: String to be parsed.\n        :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n        :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n                 string (or converted object)\n        \"\"\"\n        ds = self._dir_sep\n        path_template = self.template\n        path_template = path_template.replace(r\".\", r\"\\.\")\n        pattern_dict = {}\n        for field_name, field_conf in self.fields.items():\n            field_pattern = field_conf.pattern\n            if field_conf.is_optional:\n                field_pattern = f\"{field_pattern}|\"\n                # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n                field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n                optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n                path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n            pattern_dict[field_name] = field_pattern\n        parsed_fields = self.parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n        processed_fields = self.process_parsed_fields_values(parsed_fields)\n        return processed_fields\n\n    @classmethod\n    def check_parent_path_template(cls, path_template: str, parent_path_template: str) -&gt; None:\n        \"\"\"\n        Check if parent_path_template is coherent with path_template\n\n        :param path_template: String. Path template that follows string.Formatter() syntax.\n        :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.\n        \"\"\"\n        if parent_path_template not in path_template:\n            raise ValueError(\n                f\"path_template: '{path_template}' does not match with parent_path_template: \"\n                f\"'{parent_path_template}'. parent_path_template must be a substring of path_template\"\n            )\n\n    @classmethod\n    def prepare_fields_values(\n        cls, fields_values_dict: dict[str:Any], fields_conf: dict[str, FieldConf]\n    ) -&gt; dict[str:str]:\n        \"\"\"\n        Prepare fields values for this path\n        :param fields_values_dict: Dictionary of fields values\n        :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf)\n        :return: A dictionary of fields where the values were converted to strings.\n        \"\"\"\n        new_fields_values_dict = {}\n        for field_name, field_value in fields_values_dict.items():\n            if field_name not in fields_conf:\n                print(f\"skipping field '{field_name}'\")\n                continue\n            field_conf = fields_conf[field_name]\n\n            if field_value is None and field_conf.is_optional:\n                new_fields_values_dict[field_name] = \"\"\n                continue\n\n            if field_conf.date_format is not None:\n                new_field_value = field_value.strftime(field_conf.date_format)\n            elif field_conf.datetime_format is not None:\n                new_field_value = field_value.strftime(field_conf.datetime_format)\n            elif field_conf.var_to_str is not None:\n                new_field_value = field_conf.var_to_str(field_value)\n            else:\n                new_field_value = str(field_value)\n\n            field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n            result = re.match(field_pattern, new_field_value)\n            if result is None:\n                raise ValueError(\n                    f\"Invalid field '{field_name}' value: '{new_field_value}'. It does not match pattern: \"\n                    f\"'{field_conf.pattern}'\"\n                )\n            new_fields_values_dict[field_name] = new_field_value\n        return new_fields_values_dict\n\n    def process_parsed_fields_values(self, parsed_fields: dict[str:str]) -&gt; dict[str:Any]:\n        \"\"\"\n        Process fields values dictionary obtained from parsing a file path\n        :param parsed_fields: A dictionary of parsed fields values in string format.\n        :return: A processed dictionary of fields with converted values depending on each FieldConf definition.\n        \"\"\"\n        new_parsed_fields = parsed_fields.copy()\n\n        for field_name, field_value in new_parsed_fields.items():\n            if field_name not in self.fields:\n                raise ValueError(f\"Unknown field '{field_name}'. Valid fields are: {self.fields.keys()}\")\n            field_conf = self.fields[field_name]\n\n            field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n            if field_conf.is_optional:\n                field_pattern = f\"^{field_conf.pattern}|$\"\n            result = re.match(field_pattern, field_value)\n            if result is None:\n                raise ValueError(\n                    f\"Invalid field '{field_name}' value: '{field_value}'. It does not match pattern: \"\n                    f\"'{field_conf.pattern}'\"\n                )\n\n            if field_conf.date_format is not None:\n                new_field_value = dt.datetime.strptime(field_value, field_conf.date_format).date()\n            elif field_conf.datetime_format is not None:\n                new_field_value = dt.datetime.strptime(field_value, field_conf.datetime_format)\n            elif field_conf.str_to_var is not None:\n                new_field_value = field_conf.str_to_var(field_value)\n            else:\n                new_field_value = str(field_value)\n\n            if new_field_value == \"\" and field_conf.is_optional:\n                new_field_value = None\n\n            new_parsed_fields[field_name] = new_field_value\n        return new_parsed_fields\n\n    @classmethod\n    def _get_path(\n        cls,\n        template: str,\n        fields_conf: dict[str, FieldConf],\n        fields_values_dict: dict[str, Any],\n    ) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param template: A template that follows string.Formatter() syntax.\n        :param fields_conf: Dictionary of fields configurations, where keys are field names and values are FieldConf\n                            instances.\n        :param fields_values_dict: Input parameters dict that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        fields_values_dict = fields_values_dict.copy()\n        template_fields = cls.get_template_fields_names(template)\n        missing_fields = [field for field in template_fields if field not in fields_values_dict]\n\n        for field_name in missing_fields:\n            is_optional = fields_conf[field_name].is_optional\n            if is_optional:\n                fields_values_dict[field_name] = None\n\n        cls.check_template_fields(template, fields_values_dict)\n        fields_values_dict = cls.prepare_fields_values(fields_values_dict, fields_conf)\n        new_path = template.format(**fields_values_dict)\n        new_path = os.path.normpath(new_path)\n        return new_path\n\n    def get_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values.\n        :return: String. Path.\n        \"\"\"\n        return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n\n    def get_parent_path(self, **kwargs) -&gt; str:\n        \"\"\"\n        Generate parent path using input parameters\n\n        :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                       parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                       updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                       an error will be raised.\n        :return: String. Parent path.\n        \"\"\"\n\n        # remove all fields not present in parent template\n        parent_fields = self.fields.copy()\n        fields_names = self.get_template_fields_names(self.template)\n        parent_fields_names = self.get_template_fields_names(self.parent_template)\n\n        # Drop fields corresponding to filename\n        for field in fields_names:\n            if field not in parent_fields_names:\n                parent_fields.pop(field)\n\n        # Make dynamic the parent path creation, so the last fields can be omitted\n        # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n        new_parent_template = self.parent_template\n        dynamic_fields_names = []\n        missing_kwarg_name = None\n        for parent_field_name in parent_fields_names:\n            is_optional = parent_fields[parent_field_name].is_optional\n            if parent_field_name not in kwargs and not is_optional:\n                # keep known (left) part of parent_template and drop the rest\n                missing_kwarg_name = parent_field_name\n                new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n                break\n            dynamic_fields_names.append(parent_field_name)\n\n        # Drop fields corresponding to last arguments that were skipped\n        parent_fields_names = list(parent_fields.keys())\n        for field_name in parent_fields_names:\n            if field_name not in dynamic_fields_names:\n                parent_fields.pop(field_name)\n\n        # Check for unnecessary extra args\n        extra_kwargs = {}\n        for field_name in kwargs:\n            if field_name not in parent_fields:\n                extra_kwargs[field_name] = kwargs[field_name]\n        if missing_kwarg_name and extra_kwargs:\n            raise ValueError(\n                f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n                f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n            )\n\n        return self._get_path(\n            template=new_parent_template,\n            fields_conf=parent_fields,\n            fields_values_dict=kwargs,\n        )\n\n    def assert_path_bijection(self, test_path: str):\n        \"\"\"\n        Assert path bijection\n\n        It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n        :param test_path: Path string to be tested\n        \"\"\"\n        parsed_fields = self.parse_file_path(test_path, raise_error=True)\n        result_test_path = self.get_path(**parsed_fields)\n        assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n\n    def assert_fields_bijection(self, test_fields: dict[str, Any]):\n        \"\"\"\n        Assert fields bijection\n\n        It tries to recover the same initial input after processing once with get_path and parse_file_path\n        This method is the preferred way of checking if the PathBuilder was well-defined.\n\n        :param test_fields: Dictionary of fields to be tested\n        \"\"\"\n        test_path = self.get_path(**test_fields)\n        result_parsed_fields = self.parse_file_path(test_path, raise_error=True)\n        assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.assert_fields_bijection","title":"<code>assert_fields_bijection(test_fields)</code>","text":"<p>Assert fields bijection</p> <p>It tries to recover the same initial input after processing once with get_path and parse_file_path This method is the preferred way of checking if the PathBuilder was well-defined.</p> <p>:param test_fields: Dictionary of fields to be tested</p> Source code in <code>andar/path_builder.py</code> <pre><code>def assert_fields_bijection(self, test_fields: dict[str, Any]):\n    \"\"\"\n    Assert fields bijection\n\n    It tries to recover the same initial input after processing once with get_path and parse_file_path\n    This method is the preferred way of checking if the PathBuilder was well-defined.\n\n    :param test_fields: Dictionary of fields to be tested\n    \"\"\"\n    test_path = self.get_path(**test_fields)\n    result_parsed_fields = self.parse_file_path(test_path, raise_error=True)\n    assert test_fields == result_parsed_fields, f\"{test_fields} != {result_parsed_fields}\"\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.assert_path_bijection","title":"<code>assert_path_bijection(test_path)</code>","text":"<p>Assert path bijection</p> <p>It tries to recover the same initial input after processing once with parse_file_path and get_path</p> <p>:param test_path: Path string to be tested</p> Source code in <code>andar/path_builder.py</code> <pre><code>def assert_path_bijection(self, test_path: str):\n    \"\"\"\n    Assert path bijection\n\n    It tries to recover the same initial input after processing once with parse_file_path and get_path\n\n    :param test_path: Path string to be tested\n    \"\"\"\n    parsed_fields = self.parse_file_path(test_path, raise_error=True)\n    result_test_path = self.get_path(**parsed_fields)\n    assert test_path == result_test_path, f\"{test_path} != {result_test_path}\"\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.assign_groupname_pattern_dict","title":"<code>assign_groupname_pattern_dict(pattern_dict)</code>  <code>staticmethod</code>","text":"<p>Assign a group name to each regex pattern present in the given dictionary</p> <p>:param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not                      check if the pattern already have a group name assign. :return: A dictionary where the patterns have been assigned a group name.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@staticmethod\ndef assign_groupname_pattern_dict(pattern_dict: dict[str:str]) -&gt; dict[str:str]:\n    \"\"\"\n    Assign a group name to each regex pattern present in the given dictionary\n\n    :param pattern_dict: A dictionary of regex patterns, where each key will be used as group name. It does not\n                         check if the pattern already have a group name assign.\n    :return: A dictionary where the patterns have been assigned a group name.\n    \"\"\"\n    named_pattern_dict = {}\n    for field, pattern in pattern_dict.items():\n        named_pattern_dict[field] = f\"(?P&lt;{field}&gt;{pattern})\"\n    return named_pattern_dict\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.check_parent_path_template","title":"<code>check_parent_path_template(path_template, parent_path_template)</code>  <code>classmethod</code>","text":"<p>Check if parent_path_template is coherent with path_template</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@classmethod\ndef check_parent_path_template(cls, path_template: str, parent_path_template: str) -&gt; None:\n    \"\"\"\n    Check if parent_path_template is coherent with path_template\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :param parent_path_template: String. Parent path template that follows string.Formatter() syntax.\n    \"\"\"\n    if parent_path_template not in path_template:\n        raise ValueError(\n            f\"path_template: '{path_template}' does not match with parent_path_template: \"\n            f\"'{parent_path_template}'. parent_path_template must be a substring of path_template\"\n        )\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.check_template_fields","title":"<code>check_template_fields(path_template, map_dict)</code>  <code>classmethod</code>","text":"<p>Check if fields in the path_template are coherent with keys in the given map_dict</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :param map_dict: A dictionary where each key represent a field of the template and each value is string to be                  mapped</p> Source code in <code>andar/path_builder.py</code> <pre><code>@classmethod\ndef check_template_fields(cls, path_template: str, map_dict: dict[str:Any]) -&gt; None:\n    \"\"\"\n    Check if fields in the path_template are coherent with keys in the given map_dict\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :param map_dict: A dictionary where each key represent a field of the template and each value is string to be\n                     mapped\n    \"\"\"\n    template_fields = cls.get_template_fields_names(path_template)\n    invalid_fields = [f for f in map_dict if f not in template_fields]\n    if invalid_fields:\n        raise ValueError(f\"Invalid fields: {invalid_fields} they do not exist on path_template: '{path_template}'\")\n\n    missing_fields = [f for f in template_fields if f not in map_dict]\n    if missing_fields:\n        raise ValueError(f\"Missing fields: {missing_fields} they are required in path_template: '{path_template}'\")\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.get_parent_path","title":"<code>get_parent_path(**kwargs)</code>","text":"<p>Generate parent path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. They are used in the order of                parent_template, if the last argument(s) are omitted, the parent_template will be dynamically                updated to a shorter version. If an argument in the middle is omitted, and it is not optional,                an error will be raised. :return: String. Parent path.</p> Source code in <code>andar/path_builder.py</code> <pre><code>def get_parent_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate parent path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values. They are used in the order of\n                   parent_template, if the last argument(s) are omitted, the parent_template will be dynamically\n                   updated to a shorter version. If an argument in the middle is omitted, and it is not optional,\n                   an error will be raised.\n    :return: String. Parent path.\n    \"\"\"\n\n    # remove all fields not present in parent template\n    parent_fields = self.fields.copy()\n    fields_names = self.get_template_fields_names(self.template)\n    parent_fields_names = self.get_template_fields_names(self.parent_template)\n\n    # Drop fields corresponding to filename\n    for field in fields_names:\n        if field not in parent_fields_names:\n            parent_fields.pop(field)\n\n    # Make dynamic the parent path creation, so the last fields can be omitted\n    # for example \"{a}/{b}/{c}/{d}/\" or \"{a}/{b}/{c}/\" or \"{a}/{b}/\"\n    new_parent_template = self.parent_template\n    dynamic_fields_names = []\n    missing_kwarg_name = None\n    for parent_field_name in parent_fields_names:\n        is_optional = parent_fields[parent_field_name].is_optional\n        if parent_field_name not in kwargs and not is_optional:\n            # keep known (left) part of parent_template and drop the rest\n            missing_kwarg_name = parent_field_name\n            new_parent_template = new_parent_template.split(\"{\" + parent_field_name + \"}\", 1)[0]\n            break\n        dynamic_fields_names.append(parent_field_name)\n\n    # Drop fields corresponding to last arguments that were skipped\n    parent_fields_names = list(parent_fields.keys())\n    for field_name in parent_fields_names:\n        if field_name not in dynamic_fields_names:\n            parent_fields.pop(field_name)\n\n    # Check for unnecessary extra args\n    extra_kwargs = {}\n    for field_name in kwargs:\n        if field_name not in parent_fields:\n            extra_kwargs[field_name] = kwargs[field_name]\n    if missing_kwarg_name and extra_kwargs:\n        raise ValueError(\n            f\"Unexpected extra kwargs: {extra_kwargs}, after updating parent template \"\n            f\"to '{new_parent_template}' because of missing kwarg: '{missing_kwarg_name}'\"\n        )\n\n    return self._get_path(\n        template=new_parent_template,\n        fields_conf=parent_fields,\n        fields_values_dict=kwargs,\n    )\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.get_path","title":"<code>get_path(**kwargs)</code>","text":"<p>Generate path using input parameters</p> <p>:param kwargs: Input parameters that maps template fields to values. :return: String. Path.</p> Source code in <code>andar/path_builder.py</code> <pre><code>def get_path(self, **kwargs) -&gt; str:\n    \"\"\"\n    Generate path using input parameters\n\n    :param kwargs: Input parameters that maps template fields to values.\n    :return: String. Path.\n    \"\"\"\n    return self._get_path(template=self.template, fields_conf=self.fields, fields_values_dict=kwargs)\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.get_template_fields_names","title":"<code>get_template_fields_names(path_template)</code>  <code>staticmethod</code>","text":"<p>Get fields names from path template string</p> <p>:param path_template: String. Path template that follows string.Formatter() syntax. :return: List. Template fields names.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@staticmethod\ndef get_template_fields_names(path_template: str) -&gt; list[str]:\n    \"\"\"\n    Get fields names from path template string\n\n    :param path_template: String. Path template that follows string.Formatter() syntax.\n    :return: List. Template fields names.\n    \"\"\"\n    parsed_field_tuples = list(string.Formatter().parse(path_template))\n    template_fields_names = [name for (text, name, spec, conv) in parsed_field_tuples if name is not None]\n    return template_fields_names\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.parse_fields","title":"<code>parse_fields(_string, template, pattern_dict, raise_error=False)</code>  <code>classmethod</code>","text":"<p>Parse a string using a template and a patterns dictionary</p> <p>Example: filename_template = \"{prefix}_{name}.{extension}\" pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"} filename = \"0001_example.json\" parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict) invalid_filename = \"invalid_example.json\" parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)</p> <p>:param _string: String to be parsed. :param template: A template that follows string.Formatter() syntax. :param pattern_dict: A dictionary where each key represent a field of the template and each value is the                      corresponding regex pattern :param raise_error: Raise an exception if the path is not valid. If False, it returns None. :return: A dictionary of parsed fields.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@classmethod\ndef parse_fields(\n    cls,\n    _string: str,\n    template: str,\n    pattern_dict: dict[str:str],\n    raise_error: bool = False,\n) -&gt; dict[str:str]:\n    \"\"\"\n    Parse a string using a template and a patterns dictionary\n\n    Example:\n    filename_template = \"{prefix}_{name}.{extension}\"\n    pattern_dict = {\"prefix\": \"[0-9]{4}\", \"name\": \"[a-zA-Z0-9]+\", \"extension\": \"json\"}\n    filename = \"0001_example.json\"\n    parsed_filename_dict = parse_fields(filename, filename_template, pattern_dict)\n    invalid_filename = \"invalid_example.json\"\n    parse_fields(invalid_filename, filename_template, pattern_dict, raise_error=True)\n\n    :param _string: String to be parsed.\n    :param template: A template that follows string.Formatter() syntax.\n    :param pattern_dict: A dictionary where each key represent a field of the template and each value is the\n                         corresponding regex pattern\n    :param raise_error: Raise an exception if the path is not valid. If False, it returns None.\n    :return: A dictionary of parsed fields.\n    \"\"\"\n    cls.check_template_fields(template, pattern_dict)\n    template_fields = cls.get_template_fields_names(template)\n\n    # Deduplicate repeated fields of pattern_dict:\n    # for example the template \"/{base_path}/{asset_name}/{asset_name}_{suffix}\"\n    # will become \"/{base_path}/{asset_name__0}/{asset_name__1}_{suffix}\"\n    # and the dict {\"base_path\": r\"\\w+\", \"asset_name\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    # will become {\"base_path\": r\"\\w+\", \"asset_name__0\": r\"\\w+\", \"asset_name__1\": r\"\\w+\", \"suffix\": r\"\\d+\"}\n    unique_fields = list(set(template_fields))\n    deduplicated_fields_dict = {}\n    new_pattern_dict = {}\n    new_template = template\n    for field_name in unique_fields:\n        field_count = len([f for f in template_fields if f == field_name])\n        if field_count == 1:\n            new_pattern_dict[field_name] = pattern_dict[field_name]\n            continue\n        deduplicated_list = []\n        for idx in range(field_count):\n            new_field_name = field_name + f\"__{idx}\"\n            deduplicated_list.append(new_field_name)\n            new_pattern_dict[new_field_name] = pattern_dict[field_name]\n            new_template = new_template.replace(\"{\" + field_name + \"}\", \"{\" + new_field_name + \"}\", 1)\n        deduplicated_fields_dict[field_name] = deduplicated_list\n\n    has_duplicates = pattern_dict != new_pattern_dict\n    if has_duplicates:\n        pattern_dict = new_pattern_dict\n        template = new_template\n\n    # Build full pattern string\n    named_pattern_dict = cls.assign_groupname_pattern_dict(pattern_dict)\n    path_pattern = template.format(**named_pattern_dict)\n    path_pattern = f\"^{path_pattern}$\"  # match the full string\n    match = re.match(path_pattern, _string)\n    if not match:\n        if raise_error:\n            raise ValueError(f\"Invalid string '{_string}', expected pattern: '{path_pattern}'\")\n        return None\n    parsed_fields_dict = match.groupdict()\n\n    # Fusion deduplicated fields:\n    # it will raise an error if the deduplicate fields have multiples values\n    # for example this parsed dict will raise an error because asset_name__0 and asset_name__1 should be equal:\n    # {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"other_asset\", \"suffix\": \"001\"}\n    # if the deduplicated fields are coherent they will be fusion and renamed to its original name:\n    # for example {\"base_path\": \"folder\", \"asset_name__0\": \"my_asset\", \"asset_name__1\": \"my_asset\", \"suffix\": \"001\"}\n    # to {\"base_path\": \"folder\", \"asset_name\": \"my_asset\", \"suffix\": \"001\"}\n    for original_field_name, deduplicated_list in deduplicated_fields_dict.items():\n        parsed_field_values = [parsed_fields_dict.pop(f) for f in deduplicated_list]\n        unique_parsed_field_values = list(set(parsed_field_values))\n        are_duplicated_unique = len(unique_parsed_field_values) == 1\n        if not are_duplicated_unique:\n            raise ValueError(\n                f\"More than one value was found for repeated field '{original_field_name}': {parsed_field_values}\"\n            )\n        parsed_fields_dict[original_field_name] = unique_parsed_field_values[0]\n\n    return parsed_fields_dict\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.parse_file_path","title":"<code>parse_file_path(file_path, raise_error=False)</code>","text":"<p>Parse a file path</p> <p>:param file_path: String to be parsed. :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None. :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed          string (or converted object)</p> Source code in <code>andar/path_builder.py</code> <pre><code>def parse_file_path(self, file_path: str, raise_error: bool = False) -&gt; dict[str:Any]:\n    \"\"\"\n    Parse a file path\n\n    :param file_path: String to be parsed.\n    :param raise_error: Whether to raise an exception if the file path is not valid. By default, it returns None.\n    :return: Dictionary where each key represent a field of the template and each value is the corresponding parsed\n             string (or converted object)\n    \"\"\"\n    ds = self._dir_sep\n    path_template = self.template\n    path_template = path_template.replace(r\".\", r\"\\.\")\n    pattern_dict = {}\n    for field_name, field_conf in self.fields.items():\n        field_pattern = field_conf.pattern\n        if field_conf.is_optional:\n            field_pattern = f\"{field_pattern}|\"\n            # Allow optional directory separator for this field: \"/\" -&gt; \"/?\", by updating path_template\n            field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"{\"\n            optional_field_name_dir_sep = \"{\" + field_name + \"}\" + ds + \"?{\"\n            path_template = path_template.replace(field_name_dir_sep, optional_field_name_dir_sep)\n        pattern_dict[field_name] = field_pattern\n    parsed_fields = self.parse_fields(file_path, path_template, pattern_dict, raise_error=raise_error)\n    processed_fields = self.process_parsed_fields_values(parsed_fields)\n    return processed_fields\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.prepare_fields_values","title":"<code>prepare_fields_values(fields_values_dict, fields_conf)</code>  <code>classmethod</code>","text":"<p>Prepare fields values for this path :param fields_values_dict: Dictionary of fields values :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf) :return: A dictionary of fields where the values were converted to strings.</p> Source code in <code>andar/path_builder.py</code> <pre><code>@classmethod\ndef prepare_fields_values(\n    cls, fields_values_dict: dict[str:Any], fields_conf: dict[str, FieldConf]\n) -&gt; dict[str:str]:\n    \"\"\"\n    Prepare fields values for this path\n    :param fields_values_dict: Dictionary of fields values\n    :param fields_conf: Dictionary of fields configuration (i.e.class FieldConf)\n    :return: A dictionary of fields where the values were converted to strings.\n    \"\"\"\n    new_fields_values_dict = {}\n    for field_name, field_value in fields_values_dict.items():\n        if field_name not in fields_conf:\n            print(f\"skipping field '{field_name}'\")\n            continue\n        field_conf = fields_conf[field_name]\n\n        if field_value is None and field_conf.is_optional:\n            new_fields_values_dict[field_name] = \"\"\n            continue\n\n        if field_conf.date_format is not None:\n            new_field_value = field_value.strftime(field_conf.date_format)\n        elif field_conf.datetime_format is not None:\n            new_field_value = field_value.strftime(field_conf.datetime_format)\n        elif field_conf.var_to_str is not None:\n            new_field_value = field_conf.var_to_str(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        result = re.match(field_pattern, new_field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{new_field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n        new_fields_values_dict[field_name] = new_field_value\n    return new_fields_values_dict\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.process_parsed_fields_values","title":"<code>process_parsed_fields_values(parsed_fields)</code>","text":"<p>Process fields values dictionary obtained from parsing a file path :param parsed_fields: A dictionary of parsed fields values in string format. :return: A processed dictionary of fields with converted values depending on each FieldConf definition.</p> Source code in <code>andar/path_builder.py</code> <pre><code>def process_parsed_fields_values(self, parsed_fields: dict[str:str]) -&gt; dict[str:Any]:\n    \"\"\"\n    Process fields values dictionary obtained from parsing a file path\n    :param parsed_fields: A dictionary of parsed fields values in string format.\n    :return: A processed dictionary of fields with converted values depending on each FieldConf definition.\n    \"\"\"\n    new_parsed_fields = parsed_fields.copy()\n\n    for field_name, field_value in new_parsed_fields.items():\n        if field_name not in self.fields:\n            raise ValueError(f\"Unknown field '{field_name}'. Valid fields are: {self.fields.keys()}\")\n        field_conf = self.fields[field_name]\n\n        field_pattern = f\"^{field_conf.pattern}$\"  # Exact pattern\n        if field_conf.is_optional:\n            field_pattern = f\"^{field_conf.pattern}|$\"\n        result = re.match(field_pattern, field_value)\n        if result is None:\n            raise ValueError(\n                f\"Invalid field '{field_name}' value: '{field_value}'. It does not match pattern: \"\n                f\"'{field_conf.pattern}'\"\n            )\n\n        if field_conf.date_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.date_format).date()\n        elif field_conf.datetime_format is not None:\n            new_field_value = dt.datetime.strptime(field_value, field_conf.datetime_format)\n        elif field_conf.str_to_var is not None:\n            new_field_value = field_conf.str_to_var(field_value)\n        else:\n            new_field_value = str(field_value)\n\n        if new_field_value == \"\" and field_conf.is_optional:\n            new_field_value = None\n\n        new_parsed_fields[field_name] = new_field_value\n    return new_parsed_fields\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.replace","title":"<code>replace(**kwargs)</code>","text":"<p>Creates a copy of the current object replacing attributes with the given keyword arguments</p> <p>:param kwargs: Attributes to be replaced, same arguments as used for PathBuilder instantiation :return: A PathBuilder instance</p> Source code in <code>andar/path_builder.py</code> <pre><code>def replace(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object replacing attributes with the given keyword arguments\n\n    :param kwargs: Attributes to be replaced, same arguments as used for PathBuilder instantiation\n    :return: A PathBuilder instance\n    \"\"\"\n    default_parent_template = None\n    if \"template\" not in kwargs:\n        kwargs[\"template\"] = self.template\n        default_parent_template = self.parent_template\n    if \"parent_template\" not in kwargs:\n        kwargs[\"parent_template\"] = default_parent_template\n    if \"fields\" not in kwargs:\n        kwargs[\"fields\"] = self.fields\n    if \"default_field\" not in kwargs:\n        kwargs[\"default_field\"] = self.default_field\n\n    return self.__class__(**kwargs)\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.PathBuilder.update","title":"<code>update(**kwargs)</code>","text":"<p>Creates a copy of the current object updating attributes with the given keyword arguments :param kwargs: Attributes to be updated, same arguments as used for PathBuilder instantiation.                Fields set to None, will be reset to default, if it is no longer present on the template, it will                be removed. :return: A PathBuilder instance</p> Source code in <code>andar/path_builder.py</code> <pre><code>def update(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Creates a copy of the current object updating attributes with the given keyword arguments\n    :param kwargs: Attributes to be updated, same arguments as used for PathBuilder instantiation.\n                   Fields set to None, will be reset to default, if it is no longer present on the template, it will\n                   be removed.\n    :return: A PathBuilder instance\n    \"\"\"\n    fields = self.fields.copy()\n    if \"fields\" in kwargs:\n        fields.update(kwargs[\"fields\"])\n        fields_names = list(fields.keys())\n        [fields.pop(n) for n in fields_names if fields[n] is None]  # remove fields set to None from input args\n        kwargs[\"fields\"] = fields\n    return self.replace(**kwargs)\n</code></pre>"},{"location":"reference/andar/path_builder/#andar.path_builder.SafePatterns","title":"<code>SafePatterns</code>","text":"<p>Non-greedy patterns</p> Source code in <code>andar/path_builder.py</code> <pre><code>class SafePatterns:\n    \"\"\"\n    Non-greedy patterns\n    \"\"\"\n\n    FILENAME = r\"[-_.a-zA-Z0-9]+?\"  # include filename separators: -_.\n    DIRPATH = r\"[-_.a-zA-Z0-9/]+?\"  # include filename separators: -_. and directory separator: /\n    FIELD = r\"[a-zA-Z0-9]+?\"  # without separator characters\n    EXTENSION = r\"[.a-zA-Z0-9]+?\"  # include dots for sub extensions as 'tar.gz'\n</code></pre>"}]}